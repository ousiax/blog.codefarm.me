<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Bing WebMaster -->
  <meta name="msvalidate.01" content="AB2FFF876C37F59D9121882CC8395DE5" />

  <title>Parallel programming in .NET</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://blog.codefarm.me/2023/12/24/parallel-programming-in-net/">
  <link rel="alternate" type="application/rss+xml" title="CODE FARM" href="https://blog.codefarm.me/feed.xml">

  <!--<link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet" />-->

  <!-- https://cdn.jsdelivr.net/gh/lurongkai/anti-baidu/js/anti-baidu-latest.min.js -->
<script type="text/javascript" src="/js/anti-baidu.min.js" charset="UTF-8"></script>

  
<!-- Google Analytics Website tracking -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-83971182-1', 'auto');
  ga('send', 'pageview');

</script>


  
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SN88FJ18E5"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SN88FJ18E5');
</script>



</head>


  <body>

    <header class="site-header">

  <div class="wrapper">
    <h2 class="site-title">
      <a class="site-title" href="/">CODE FARM</a>
    </h2>

     <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>
        <div class="trigger">
            <ul>
                <li><a href="/">home</a>
                <li><a href="/category">category</a>
                <li><a href="/tag">tag</a>
                <li><a href="/archive">archive</a>
                <li><a href="/about">about</a>
                <li><a href="https://resume.github.io/?ousiax" target="_blank">R&eacute;sum&eacute;</a>
            </ul>
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Parallel programming in .NET</h1>
    
    
    <p class="post-meta"><time datetime="2023-12-24T12:56:21+08:00" itemprop="datePublished">Feb 3, 2025</time></p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <div id="preamble">
<div class="sectionbody">
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>"Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once." — Rob Pike</p>
</div>
</blockquote>
</div>
</div>
<div id="toc" class="toc">
<div id="toctitle"></div>
<ul class="sectlevel1">
<li><a href="#threads-and-threading">1. Threads and threading</a>
<ul class="sectlevel2">
<li><a href="#processes-and-threads">1.1. Processes and threads</a></li>
<li><a href="#how-to-use-multithreading-in-net">1.2. How to use multithreading in .NET</a></li>
<li><a href="#using-threads-and-threading">1.3. Using threads and threading</a>
<ul class="sectlevel3">
<li><a href="#create-and-start-a-new-thread">1.3.1. Create and start a new thread</a></li>
<li><a href="#stop-a-thread">1.3.2. Stop a thread</a></li>
<li><a href="#pause-or-interrupt-a-thread">1.3.3. Pause or interrupt a thread</a></li>
<li><a href="#busy-waiting">1.3.4. Busy waiting</a></li>
</ul>
</li>
<li><a href="#cancellation-in-managed-threads">1.4. Cancellation in Managed Threads</a></li>
<li><a href="#foreground-and-background-threads">1.5. Foreground and background threads</a></li>
<li><a href="#the-managed-thread-pool">1.6. The managed thread pool</a>
<ul class="sectlevel3">
<li><a href="#thread-pool-characteristics">1.6.1. Thread pool characteristics</a></li>
<li><a href="#exceptions-in-thread-pool-threads">1.6.2. Exceptions in thread pool threads</a></li>
<li><a href="#maximum-number-of-thread-pool-threads">1.6.3. Maximum number of thread pool threads</a></li>
<li><a href="#thread-pool-minimums">1.6.4. Thread pool minimums</a></li>
<li><a href="#when-not-to-use-thread-pool-threads">1.6.5. When not to use thread pool threads</a></li>
</ul>
</li>
<li><a href="#overview-of-synchronization-primitives">1.7. Overview of synchronization primitives</a>
<ul class="sectlevel3">
<li><a href="#waithandle-and-lightweight-synchronization-types">1.7.1. WaitHandle and lightweight synchronization types</a></li>
<li><a href="#synchronization-of-access-to-a-shared-resource">1.7.2. Synchronization of access to a shared resource</a>
<ul class="sectlevel4">
<li><a href="#monitor">1.7.2.1. Monitor</a></li>
<li><a href="#lock">1.7.2.2. Lock</a></li>
<li><a href="#mutex">1.7.2.3. Mutex</a></li>
<li><a href="#spinlock">1.7.2.4. SpinLock</a></li>
<li><a href="#spinwait">1.7.2.5. SpinWait</a></li>
<li><a href="#readerwriterlockslim">1.7.2.6. ReaderWriterLockSlim</a></li>
<li><a href="#semaphore-and-semaphoreslim">1.7.2.7. Semaphore and SemaphoreSlim</a></li>
</ul>
</li>
<li><a href="#thread-interaction-or-signaling">1.7.3. Thread interaction, or signaling</a>
<ul class="sectlevel4">
<li><a href="#eventwaithandle">1.7.3.1. EventWaitHandle</a></li>
<li><a href="#countdownevent">1.7.3.2. CountdownEvent</a></li>
<li><a href="#barrier">1.7.3.3. Barrier</a></li>
</ul>
</li>
<li><a href="#interlocked">1.7.4. Interlocked</a></li>
</ul>
</li>
<li><a href="#the-volatile-keyword">1.8. The volatile keyword</a></li>
<li><a href="#threadlocalt">1.9. ThreadLocal&lt;T&gt;</a></li>
<li><a href="#lazyt">1.10. Lazy&lt;T&gt;</a></li>
<li><a href="#thread-safe-collections">1.11. Thread-safe collections</a></li>
</ul>
</li>
<li><a href="#asynchronous-programming">2. Asynchronous programming</a>
<ul class="sectlevel2">
<li><a href="#tasks-and-valuetasks">2.1. Tasks and ValueTasks</a></li>
<li><a href="#executioncontext-and-synchronizationcontext">2.2. ExecutionContext and SynchronizationContext</a></li>
<li><a href="#asynclocalt">2.3. AsyncLocal&lt;T&gt;</a></li>
<li><a href="#wpf-threading-model">2.4. WPF threading model</a></li>
<li><a href="#the-async-and-await-keywords">2.5. The async and await keywords</a></li>
<li><a href="#task-configureawait">2.6. Task.ConfigureAwait</a></li>
<li><a href="#system-threading-channels">2.7. System.Threading.Channels</a></li>
</ul>
</li>
<li><a href="#parallel-programming-in-net">3. Parallel programming in .NET</a>
<ul class="sectlevel2">
<li><a href="#task-parallel-library-tpl">3.1. Task Parallel Library (TPL)</a></li>
<li><a href="#data-parallelism">3.2. Data Parallelism</a></li>
<li><a href="#dataflow">3.3. Dataflow</a></li>
<li><a href="#parallel-linq-plinq">3.4. Parallel LINQ (PLINQ)</a></li>
</ul>
</li>
<li><a href="#faq">Appendix A: FAQ</a>
<ul class="sectlevel2">
<li><a href="#what-happens-on-thread-sleep0-in-net">A.1. What happens on Thread.Sleep(0) in .NET?</a></li>
<li><a href="#what-are-the-worker-and-completion-port-threads">A.2. What are the worker and completion port threads?</a></li>
<li><a href="#how-does-net-identify-io-bound-or-compute-bound-operations">A.3. How does .NET identify I/O-bound or compute-bound operations?</a></li>
<li><a href="#how-does-clr-manage-the-number-of-threads-worker-and-io-threads-in-the-threadpool">A.4. How does CLR manage the number of threads (worker and I/O threads) in the ThreadPool?</a></li>
<li><a href="#whats-the-algorithm-of-the-thread-pool-in-net">A.5. What&#8217;s the algorithm of the thread pool in .NET?</a></li>
<li><a href="#what-if-interlocked-increment-a-64-bit-integer-on-a-32-bit-hardware">A.6. What if Interlocked.Increment a 64-bit integer on a 32-bit hardware?</a></li>
<li><a href="#how-does-net-make-the-multiple-cpu-instructions-as-an-atomic">A.7. How does .NET make the multiple CPU instructions as an atomic?</a></li>
<li><a href="#i-heard-there-are-some-risk-on-atomic-operations-in-go-or-sth-else">A.8. I heard there are some risk on atomic operations in Go or sth else?</a></li>
<li><a href="#whats-aba-problems">A.9. What&#8217;s ABA problems?</a></li>
<li><a href="#how-to-understand-hardware-compilers-and-the-language-memory-model">A.10. How to understand 'hardware, compilers, and the language memory model'?</a></li>
<li><a href="#anyway-for-a-single-operation-like-interlocked-increment-it-will-always-ensure-it-as-an-atomic">A.11. Anyway, for a single operation like Interlocked.Increment, it will always ensure it as an atomic?</a></li>
<li><a href="#how-to-understand-the-volatile-keyword-in-net">A.12. How to understand the volatile keyword in .NET?</a></li>
<li><a href="#whats-the-diff-of-volatile-keyword-and-volatile-class">A.13. What&#8217;s the diff of volatile keyword and Volatile class?</a></li>
<li><a href="#it-seems-we-should-avoid-to-use-the-volatile-keyword">A.14. It seems we should avoid to use the volatile keyword?</a></li>
<li><a href="#whats-the-diff-of-asynchronous-and-parallel-programming-in-net">A.15. What&#8217;s the diff of asynchronous and parallel programming in .NET?</a></li>
<li><a href="#whats-the-control-meaning-in-async-and-await-programming">A.16. What&#8217;s the control meaning in async and await programming?</a></li>
<li><a href="#how-to-understand-async-methods-dont-require-multithreading-because-an-async-method-doesnt-run-on-its-own-thread">A.17. How to understand "Async methods don&#8217;t require multithreading because an async method doesn&#8217;t run on its own thread."?</a></li>
<li><a href="#can-the-asyncawait-improve-the-responsiveness-on-asp-net-core">A.18. Can the async/await improve the responsiveness on ASP.NET Core?</a></li>
<li><a href="#is-there-a-synchronizationcontext-on-asp-net-core">A.19. Is there a SynchronizationContext on ASP.NET Core?</a></li>
<li><a href="#whats-the-diff-of-asordered-and-asunordered-in-plinq">A.20. What&#8217;s the diff of AsOrdered and AsUnordered in PLINQ?</a></li>
</ul>
</li>
<li><a href="#references">References</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="threads-and-threading">1. Threads and threading</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multithreading can be used to increase the responsiveness of an application and, if an application runs on a multiprocessor or multi-core system, increase its throughput. <a href="#bib-threads-and-threading">[1]</a></p>
</div>
<div class="sect2">
<h3 id="processes-and-threads">1.1. Processes and threads</h3>
<div class="paragraph">
<p>A <em>process</em> is an executing program and an operating system uses processes to separate the applications that are being executed.</p>
</div>
<div class="paragraph">
<p>A <em>thread</em> is the basic unit to which an operating system allocates <em>processor time</em>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each thread has a scheduling <em>priority</em> and maintains a set of structures the system uses to save the thread <em>context</em> when the thread&#8217;s execution is paused.</p>
</li>
<li>
<p>The thread context includes all the information the thread needs to seamlessly resume execution, including the thread&#8217;s set of CPU <em>registers</em> and <em>stack</em>.</p>
</li>
<li>
<p>Multiple threads can run in the context of a process.</p>
<div class="ulist">
<ul>
<li>
<p>All threads of a process share its <em>virtual address space</em>.</p>
</li>
<li>
<p>A thread can execute any part of the program code, including parts currently being executed by another thread.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
.NET Framework provides a way to isolate applications within a process with the use of application domains. (Application domains are not available on .NET Core.)
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>By default, a .NET program is started with a single thread, often called the <em>primary thread</em>. However, it can create additional threads to execute code in parallel or concurrently with the primary thread. These threads are often called <em>worker threads</em>.</p>
</div>
</div>
<div class="sect2">
<h3 id="how-to-use-multithreading-in-net">1.2. How to use multithreading in .NET</h3>
<div class="paragraph">
<p>Starting with .NET Framework 4, the recommended way to utilize multithreading is to use <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</a> and <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq">Parallel LINQ (PLINQ)</a>.</p>
</div>
<div class="paragraph">
<p>Both TPL and PLINQ rely on the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool">ThreadPool</a> threads. The <code>System.Threading.ThreadPool</code> class provides a .NET application with a pool of worker threads.</p>
</div>
<div class="paragraph">
<p>At last, the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread">System.Threading.Thread</a> class represents a managed thread.</p>
</div>
</div>
<div class="sect2">
<h3 id="using-threads-and-threading">1.3. Using threads and threading</h3>
<div class="paragraph">
<p>With .NET, applications can be wrote that perform multiple operations at the same time. Operations with the potential of holding up other operations can execute on separate threads, a process that is known as <em>multithreading</em> or <em>free threading</em>. <a href="#bib-using-threads-and-threading">[2]</a></p>
</div>
<div class="sect3">
<h4 id="create-and-start-a-new-thread">1.3.1. Create and start a new thread</h4>
<div class="paragraph">
<p>A new thread can be created by creating a new instance of the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread"><code>System.Threading.Thread</code></a> class. A delegate or method name can be provided to the constructor to be executed on the new thread. To start a created thread, call the <code>Thread.Start</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Hello Thread"</span><span class="p">)).</span><span class="nf">Start</span><span class="p">();</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="stop-a-thread">1.3.2. Stop a thread</h4>
<div class="paragraph">
<p>To terminate the execution of a thread, use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken">System.Threading.CancellationToken</a> which provides a unified way to cooperatively stop threads.</p>
</div>
<div class="paragraph">
<p>Sometimes it&#8217;s not possible to stop a thread cooperatively because it runs third-party code not designed for cooperative cancellation. To terminate the execution of a thread forcibly, in .NET Framework, use the <code>Thread.Abort</code> method that raises a <code>ThreadAbortException</code> on the thread on which it&#8217;s invoked.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.abort"><code>Thread.Abort</code></a> method isn&#8217;t supported in .NET Core. To terminate the execution of third-party code forcibly in .NET Core, run it in the separate process and use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process.kill"><code>Process.Kill</code></a> method.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.join"><code>Thread.Join</code></a> method to make the calling thread (that is, the thread that calls the method) wait for the termination of the thread being stopped.</p>
</div>
</div>
<div class="sect3">
<h4 id="pause-or-interrupt-a-thread">1.3.3. Pause or interrupt a thread</h4>
<div class="paragraph">
<p>Use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.sleep"><code>Thread.Sleep</code></a> method to pause the current thread for a specified amount of time. A blocked thread can be interrupted by calling the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.interrupt"><code>Thread.Interrupt</code></a> method.</p>
</div>
<div class="paragraph">
<p>Calling the <code>Thread.Sleep</code> method causes the current thread to immediately block for the number of milliseconds or the time interval that passed to the method, and yields the remainder of its time slice to another thread. Once that interval elapses, the sleeping thread resumes execution. <a href="#pausing-and-resuming-threads">[4]</a></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Calling the <code>Thread.Sleep(0)</code> causes the current thread to yield its remaining time slice immediately, voluntarily handing over the CPU to other threads, though it might not lead to a context switch if no same- or higher-priority threads are waiting.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Calling <code>Thread.Sleep</code> with a value of <code>Timeout.Infinite</code> causes a thread to sleep until it is interrupted by another thread that calls the <code>Thread.Interrupt</code> method on the sleeping thread, or until it is terminated by a call to its <code>Thread.Abort</code> method.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
One thread cannot call <code>Thread.Sleep</code> on another thread. <code>Thread.Sleep</code> is a static method that always causes the current thread to sleep.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>A waiting thread can be interrupted by calling the <code>Thread.Interrupt</code> to throw a <code>ThreadInterruptedException</code> to break the thread out of the blocking call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Interrupts a thread that is in the WaitSleepJoin thread state.</span>
<span class="k">public</span> <span class="k">void</span> <span class="nf">Interrupt</span> <span class="p">();</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>The waiting thread should catch the <code>ThreadInterruptedException</code> and do whatever is appropriate to continue working.</p>
</li>
<li>
<p>If the thread ignores the exception, the runtime catches the exception and stops the thread.</p>
</li>
<li>
<p>If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</p>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadstate#system-threading-threadstate-waitsleepjoin"><code>ThreadState.WaitSleepJoin</code></a>: The thread is blocked.</p>
</div>
<div class="paragraph">
<p>This could be the result of calling <code>Sleep(Int32)</code> or <code>Join()</code>, of requesting a lock - for example, by calling <code>Enter(Object)</code> or <code>Wait(Object, Int32, Boolean)</code> - or of waiting on a thread synchronization object such as <code>ManualResetEvent</code>.</p>
</div>
</blockquote>
</div>
</li>
<li>
<p>If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</p>
</li>
<li>
<p>If a wait is a managed wait, then <code>Thread.Interrupt</code> and <code>Thread.Abort</code> both wake the thread immediately.</p>
</li>
<li>
<p>If a wait is an unmanaged wait (for example, a platform invoke call to the Win32 <code>WaitForSingleObject</code> function), neither <code>Thread.Interrupt</code> nor <code>Thread.Abort</code> can take control of the thread until it returns to or calls into managed code.</p>
</li>
<li>
<p>In managed code, the behavior is as follows:</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p><code>Thread.Interrupt</code> wakes a thread out of any wait it might be in and causes a <code>ThreadInterruptedException</code> to be thrown in the destination thread.</p>
</li>
<li>
<p>.NET Framework only: <code>Thread.Abort</code> wakes a thread out of any wait it might be in and causes a <code>ThreadAbortException</code> to be thrown on the thread.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">Thread</span> <span class="n">sleepingThread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread '{0}' about to sleep indefinitely."</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="n">Timeout</span><span class="p">.</span><span class="n">Infinite</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">ThreadInterruptedException</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread '{0}' awoken."</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread '{0}' executing finally block."</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Thread '{0} finishing normal execution."</span><span class="p">,</span> <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
<span class="p">});</span>

<span class="n">sleepingThread</span><span class="p">.</span><span class="n">Name</span> <span class="p">=</span> <span class="s">"Sleeping"</span><span class="p">;</span>
<span class="n">sleepingThread</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">2000</span><span class="p">);</span>
<span class="n">sleepingThread</span><span class="p">.</span><span class="nf">Interrupt</span><span class="p">();</span>

<span class="c1">// Thread 'Sleeping' about to sleep indefinitely.</span>
<span class="c1">// Thread 'Sleeping' awoken.</span>
<span class="c1">// Thread 'Sleeping' executing finally block.</span>
<span class="c1">// Thread 'Sleeping finishing normal execution.</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="busy-waiting">1.3.4. Busy waiting</h4>
<div class="paragraph">
<p><em>Busy waiting</em> (a.k.a, <em>spinning</em>) is a technique where a thread repeatedly checks for a condition to be true without releasing the CPU, which can lead to inefficient CPU usage.</p>
</div>
<div class="paragraph">
<p>Calling the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.spinwait"><code>Thread.SpinWait</code></a> method causes a thread to wait the number of times defined by the <code>iterations</code> parameter.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In contrast to blocking (like using <code>Thread.Sleep()</code> or synchronization primitives as locks), a busy-waiting thread continuously polls a condition, consuming CPU cycles even though it&#8217;s not performing useful work.</p>
</li>
<li>
<p>Compared to a basic loop, <code>Thread.SpinWait</code> minimizes CPU waste by adjusting its spinning behavior with adaptive spinning and hardware-level optimizations, backing off after a few spins, and may yield control to the OS for a context switch once a threshold is reached.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">int</span> <span class="n">iterations</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>  <span class="c1">// Number of spins before the thread may yield</span>
<span class="k">while</span> <span class="p">(!</span><span class="n">conditionMet</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Thread</span><span class="p">.</span><span class="nf">SpinWait</span><span class="p">(</span><span class="n">iterations</span><span class="p">);</span>  <span class="c1">// Spins for the specified number of iterations</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.spinwait"><code>System.Threading.SpinWait</code></a> struct provides a more fine-grained control over busy-waiting to be used in low-level scenarios to avoid the expensive context switches and kernel transitions that are required for kernel events.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Example using SpinWait struct</span>
<span class="n">SpinWait</span> <span class="n">spinWait</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SpinWait</span><span class="p">();</span>
<span class="k">while</span> <span class="p">(!</span><span class="n">conditionMet</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">spinWait</span><span class="p">.</span><span class="nf">SpinOnce</span><span class="p">();</span>  <span class="c1">// Spins once, then decides whether to continue spinning or yield</span>

    <span class="c1">// check the number of spins and decide how to proceed</span>
    <span class="kt">int</span> <span class="n">spinCount</span> <span class="p">=</span> <span class="n">spinWait</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span>
    <span class="c1">// . . .</span>

    <span class="c1">// check the state of NextSpinWillYield</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">spinWait</span><span class="p">.</span><span class="n">NextSpinWillYield</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// The next spin will yield control to more likely give up CPU time</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cancellation-in-managed-threads">1.4. Cancellation in Managed Threads</h3>
<div class="paragraph">
<p>Starting with .NET Framework 4, .NET uses a unified model for cooperative cancellation of asynchronous or long-running synchronous operations which is based on a lightweight object called a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken"><em>cancellation token</em></a>. <a href="#bib-cancellation-in-managed-threads">[3]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The object that invokes one or more cancelable operations, for example by creating new threads or tasks, passes the token to each operation. Individual operations can in turn pass copies of the token to other operations.</p>
</li>
<li>
<p>At some later time, the object that created the token can use it to request that the operations stop what they are doing.</p>
</li>
<li>
<p>Only the requesting object can issue the cancellation request, and each listener is responsible for noticing the request and responding to it in an appropriate and timely manner.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The general pattern for implementing the cooperative cancellation model is:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Instantiate a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource"><code>CancellationTokenSource</code></a> object, which manages and sends cancellation notification to the individual cancellation tokens.</p>
</li>
<li>
<p>Pass the token returned by the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.token"><code>CancellationTokenSource.Token</code></a> property to each task or thread that listens for cancellation.</p>
</li>
<li>
<p>Provide a mechanism for each task or thread to respond to cancellation.</p>
</li>
<li>
<p>Call the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.cancel"><code>CancellationTokenSource.Cancel</code></a> method to provide notification of cancellation.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Create the token source.</span>
<span class="n">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>

<span class="c1">// Pass the token to the cancelable operation.</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">obj</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="k">is</span> <span class="n">CancellationToken</span> <span class="n">token</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">token</span><span class="p">.</span><span class="n">IsCancellationRequested</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"In iteration {0}, cancellation has been requested..."</span><span class="p">,</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
                <span class="c1">// Perform cleanup if necessary.</span>
                <span class="c1">//...</span>
                <span class="c1">// Terminate the operation.</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// Simulate some work.</span>
            <span class="n">Thread</span><span class="p">.</span><span class="nf">SpinWait</span><span class="p">(</span><span class="m">500000</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">);</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">2500</span><span class="p">);</span>

<span class="c1">// Request cancellation.</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Cancellation set in token source..."</span><span class="p">);</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">2500</span><span class="p">);</span>
<span class="c1">// Cancellation should have happened, so call Dispose.</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span> <span class="c1">// or using CancellationTokenSource cts = ...</span>

<span class="c1">// The example displays output like the following:</span>
<span class="c1">//       Cancellation set in token source...</span>
<span class="c1">//       In iteration 1430, cancellation has been requested...</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The <code>CancellationTokenSource</code> class implements the <code>IDisposable</code> interface. Be sure to call the <code>Dispose</code> method when finished using the cancellation token source to free any unmanaged resources it holds.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following illustration shows the relationship between a token source and all the copies of its token.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/standard/threading/media/vs-cancellationtoken.png" alt="CancellationTokenSource and cancellation tokens" width="45%" height="45%">
</div>
</div>
<div class="paragraph">
<p>The cooperative cancellation model makes it easier to create cancellation-aware applications and libraries, and it supports the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cancellation is cooperative and is not forced on the listener. The listener determines how to gracefully terminate in response to a cancellation request.</p>
</li>
<li>
<p>Requesting is distinct from listening. An object that invokes a cancelable operation can control when (if ever) cancellation is requested.</p>
</li>
<li>
<p>The requesting object issues the cancellation request to all copies of the token by using just one method call.</p>
</li>
<li>
<p>A listener can listen to multiple tokens simultaneously by joining them into one <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.createlinkedtokensource"><em>linked token</em></a>.</p>
</li>
<li>
<p>User code can notice and respond to cancellation requests from library code, and library code can notice and respond to cancellation requests from user code.</p>
</li>
<li>
<p>Listeners can be notified of cancellation requests by polling, callback registration, or waiting on wait handles.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In more complex cases, it might be necessary for the user delegate to notify library code that cancellation has occurred.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In such cases, the correct way to terminate the operation is for the delegate to call the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.throwifcancellationrequested"><code>ThrowIfCancellationRequested()</code></a>, method, which will cause an <code>OperationCanceledException</code> to be thrown.</p>
</li>
<li>
<p>Library code can catch this exception on the user delegate thread and examine the exception&#8217;s token to determine whether the exception indicates cooperative cancellation or some other exceptional situation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>System.Threading.Tasks.Task</code> and <code>System.Threading.Tasks.Task&lt;TResult&gt;</code> classes support cancellation by using cancellation tokens. The operation can be terminated by using one of these options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By returning from the delegate. In many scenarios, this option is sufficient. However, a task instance that&#8217;s canceled in this way transitions to the <code>TaskStatus.RanToCompletion</code> state, not to the <code>TaskStatus.Canceled</code> state.</p>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p>By throwing an <a href="https://learn.microsoft.com/en-us/dotnet/api/system.operationcanceledexception"><code>OperationCanceledException</code></a> and passing it the token on which cancellation was requested.</p>
</li>
<li>
<p>The preferred way to perform is to use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtoken.throwifcancellationrequested"><code>ThrowIfCancellationRequested</code></a> method to throw a <code>OperationCanceledException</code> if this token has had cancellation requested.</p>
<div class="paragraph">
<p>A task that&#8217;s canceled in this way transitions to the <code>Canceled</code> state, which the calling code can use to verify that the task responded to its cancellation request.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a task instance observes an <code>OperationCanceledException</code> thrown by the user code, it compares the exception&#8217;s token to its associated token (the one that was passed to the API that created the Task).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the tokens are same and the token&#8217;s <code>IsCancellationRequested</code> property returns <code>true</code>, the task interprets this as acknowledging cancellation and transitions to the <code>Canceled</code> state.</p>
</li>
<li>
<p>If don&#8217;t use a <code>Wait</code> or <code>WaitAll</code> method to wait for the task, then the task just sets its status to <code>Canceled</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a Task is being waited on and it transitions to the <code>Canceled</code> state, a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskcanceledexception"><code>System.Threading.Tasks.TaskCanceledException</code></a> exception wrapped in an <a href="https://learn.microsoft.com/en-us/dotnet/api/system.aggregateexception"><code>AggregateException</code></a> exception is thrown to indicate successful cancellation instead of a faulty situation. Therefore, the task&#8217;s <code>Exception</code> property returns <code>null</code>.</p>
</div>
<div class="paragraph">
<p>If the token&#8217;s <code>IsCancellationRequested</code> property returns <code>false</code> or if the exception&#8217;s token doesn&#8217;t match the Task&#8217;s token, the <code>OperationCanceledException</code> is treated like a normal exception, causing the Task to transition to the <code>Faulted</code> state. The presence of other exceptions will also cause the Task to transition to the <code>Faulted</code> state.</p>
</div>
<div class="paragraph">
<p>It&#8217;s possible that a task might continue to process some items after cancellation is requested.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Please note that if use <code>Task.Run(() => &#8230;&#8203;, cancellationToken)</code>, then cancellation before execution leads to a <code>Task</code> in <code>Canceled</code> status. Just ensure to pass the <code>CancellationToken</code> as an argument to the <code>Task.Run</code> method.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">using</span> <span class="nn">CancellationTokenSource</span> <span class="n">cts</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CancellationTokenSource</span><span class="p">();</span>
<span class="n">CancellationToken</span> <span class="n">ct</span> <span class="p">=</span> <span class="n">cts</span><span class="p">.</span><span class="n">Token</span><span class="p">;</span>

<span class="n">Task</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="n">ct</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">SpinWait</span><span class="p">(</span><span class="m">500000</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">},</span> <span class="n">ct</span><span class="p">);</span>

<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="n">cts</span><span class="p">.</span><span class="nf">Cancel</span><span class="p">();</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">try</span>
<span class="p">{</span>
    <span class="n">task</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">AggregateException</span> <span class="n">ae</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Task.Status: </span><span class="p">{</span><span class="n">task</span><span class="p">.</span><span class="n">Status</span><span class="p">}</span><span class="s">. Task.Exception: </span><span class="p">{</span><span class="n">task</span><span class="p">.</span><span class="n">Exception</span> <span class="k">is</span> <span class="k">null</span><span class="p">}</span><span class="s">."</span>
        <span class="p">+</span> <span class="s">$" Catched: </span><span class="p">{</span><span class="n">ae</span><span class="p">.</span><span class="n">InnerException</span><span class="p">?.</span><span class="nf">GetType</span><span class="p">().</span><span class="n">Name</span><span class="p">}</span><span class="s">."</span><span class="p">);</span>
    <span class="c1">// Task.Status: Canceled. Task.Exception: True. Catched: TaskCanceledException.</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">try</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">task</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">OperationCanceledException</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Task.Status: </span><span class="p">{</span><span class="n">task</span><span class="p">.</span><span class="n">Status</span><span class="p">}</span><span class="s">. Task.Exception: </span><span class="p">{</span><span class="n">task</span><span class="p">.</span><span class="n">Exception</span> <span class="k">is</span> <span class="k">null</span><span class="p">}</span><span class="s">."</span><span class="p">);</span>
    <span class="c1">// Task.Status: Canceled. Task.Exception: True.</span>
<span class="p">}</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="foreground-and-background-threads">1.5. Foreground and background threads</h3>
<div class="paragraph">
<p>A managed thread is either a background thread or a foreground thread.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Background threads are identical to foreground threads with one exception: a background thread does not keep the managed execution environment running.</p>
</li>
<li>
<p>Once all foreground threads have been stopped in a managed process (where the .exe file is a managed assembly), the system stops all background threads and shuts down.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread.isbackground"><code>Thread.IsBackground</code></a> property to determine whether a thread is a background or a foreground thread, or to change its status.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Threads that belong to the managed thread pool (that is, threads whose <code>IsThreadPoolThread</code> property is <code>true</code>) are background threads.</p>
</li>
<li>
<p>All threads that enter the managed execution environment from unmanaged code are marked as background threads.</p>
</li>
<li>
<p>All threads generated by creating and starting a new <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.thread"><code>Thread</code></a> object are by default foreground threads.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span> <span class="c1">// no effect</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"IsBackground: </span><span class="p">{</span><span class="n">Thread</span><span class="p">.</span><span class="n">CurrentThread</span><span class="p">.</span><span class="n">IsBackground</span><span class="p">}</span><span class="s">"</span><span class="p">);</span> <span class="c1">// IsBackground: False</span>
<span class="p">});</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ThreadPool</code> has its own management system and controls thread life-cycles, where it always treats its threads as background threads, which means that those threads will not prevent a process from terminating, and the thread pool will ignore this setting.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="the-managed-thread-pool">1.6. The managed thread pool</h3>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool">System.Threading.ThreadPool</a> class provides an application with a pool of worker threads that are managed by the system, allowing concentration on application tasks rather than thread management. <a href="#bib-the-managed-thread-pool">[5]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>For <strong>short tasks</strong> that require background processing, the managed thread pool is an easy way to take advantage of multiple threads.</p>
</li>
<li>
<p>Use of the thread pool is significantly easier in Framework 4 and later, since <code>Task</code> and <code>Task&lt;TResult&gt;</code> objects can be created to perform asynchronous tasks on thread pool threads.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>.NET uses thread pool threads for many purposes, including <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl">Task Parallel Library (TPL)</a> operations, <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/">asynchronous I/O completion</a>, <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/timers">timer</a> callbacks, registered wait operations, asynchronous method calls using delegates, and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.net">System.Net</a> socket connections.</p>
</div>
<div class="sect3">
<h4 id="thread-pool-characteristics">1.6.1. Thread pool characteristics</h4>
<div class="paragraph">
<p>Thread pool threads are background threads.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Each thread uses the default stack size, runs at the default priority, and is in the multithreaded apartment.</p>
</li>
<li>
<p>Once a thread in the thread pool completes its task, it&#8217;s returned to a queue of waiting threads, where it can be reused, thus avoiding the cost of creating a new thread for each task.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
There is only one thread pool per process.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">MyThreadPool</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="k">static</span> <span class="n">BlockingCollection</span><span class="p">&lt;(</span><span class="n">Action</span><span class="p">,</span> <span class="n">ExecutionContext</span><span class="p">?)&gt;</span> <span class="n">s_workItems</span> <span class="p">=</span> <span class="p">[];</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">Action</span> <span class="n">callBack</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">s_workItems</span><span class="p">.</span><span class="nf">Add</span><span class="p">((</span><span class="n">callBack</span><span class="p">,</span> <span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">Capture</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="nf">MyThreadPool</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Environment</span><span class="p">.</span><span class="n">ProcessorCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="k">new</span> <span class="nf">Thread</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="p">(</span><span class="n">Action</span> <span class="n">workItem</span><span class="p">,</span> <span class="n">ExecutionContext</span><span class="p">?</span> <span class="n">context</span><span class="p">)</span> <span class="p">=</span> <span class="n">s_workItems</span><span class="p">.</span><span class="nf">Take</span><span class="p">();</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">context</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="nf">workItem</span><span class="p">();</span>
                    <span class="p">}</span>
                    <span class="k">else</span>
                    <span class="p">{</span>
                        <span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="k">delegate</span> <span class="p">{</span> <span class="nf">workItem</span><span class="p">();</span> <span class="p">},</span> <span class="k">null</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">})</span>
            <span class="p">{</span> <span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span> <span class="p">}.</span><span class="nf">UnsafeStart</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="exceptions-in-thread-pool-threads">1.6.2. Exceptions in thread pool threads</h4>
<div class="paragraph">
<p>Unhandled exceptions in thread pool threads terminate the process. There are three exceptions to this rule:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>System.Threading.ThreadAbortException</code> is thrown in a thread pool thread because <code>Thread.Abort</code> was called.</p>
</li>
<li>
<p>A <code>System.AppDomainUnloadedException</code> is thrown in a thread pool thread because the application domain is being unloaded.</p>
</li>
<li>
<p>The common language runtime or a host process terminates the thread.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="maximum-number-of-thread-pool-threads">1.6.3. Maximum number of thread pool threads</h4>
<div class="paragraph">
<p>The number of operations that can be queued to the thread pool is limited only by available memory. However, the thread pool limits the number of threads that can be active in the process simultaneously.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If all thread pool threads are busy, additional work items are queued until threads to execute them become available.</p>
</li>
<li>
<p>The default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</p>
</li>
<li>
<p>A process can call the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool.getmaxthreads"><code>ThreadPool.GetMaxThreads</code></a> method to determine the number of threads.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="thread-pool-minimums">1.6.4. Thread pool minimums</h4>
<div class="paragraph">
<p>The thread pool provides new worker threads or <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports">I/O completion</a> threads on demand until it reaches a specified minimum for each category.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A process can use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool.getminthreads"><code>ThreadPool.GetMinThreads</code></a> method to obtain these minimum values.</p>
</li>
<li>
<p>When demand is low, the actual number of thread pool threads can fall below the minimum values.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a minimum is reached, the thread pool can create additional threads or wait until some tasks complete.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</p>
</li>
<li>
<p>Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>A process can use the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool.setminthreads"><code>ThreadPool.SetMinThreads</code></a> method to increase the minimum number of idle threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own Hill Climbing (HC) algorithm for allocating threads. <a href="#performance-improvements-in-net-6">[24]</a> <a href="#concurrency-throttling-concurrency-in-the-clr-4-0-threadpool">[25]</a></p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="when-not-to-use-thread-pool-threads">1.6.5. When not to use thread pool threads</h4>
<div class="paragraph">
<p>There are several scenarios in which it’s appropriate to create and manage threads instead of using thread pool threads:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A foreground thread is required.</p>
</li>
<li>
<p>A thread with a particular priority is needed.</p>
</li>
<li>
<p>Tasks cause the thread to block for long periods of time. The thread pool has a maximum number of threads, so a large number of blocked thread pool threads might prevent tasks from starting.</p>
</li>
<li>
<p>Threads need to be placed into a single-threaded apartment. All ThreadPool threads are in the multithreaded apartment.</p>
</li>
<li>
<p>A stable identity needs to be associated with the thread, or a thread should be dedicated to a task.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="overview-of-synchronization-primitives">1.7. Overview of synchronization primitives</h3>
<div class="paragraph">
<p>.NET provides a range of types to synchronize access to a shared resource or coordinate thread interaction. <a href="#bib-overview-of-synchronization-primitives">[6]</a></p>
</div>
<div class="sect3">
<h4 id="waithandle-and-lightweight-synchronization-types">1.7.1. WaitHandle and lightweight synchronization types</h4>
<div class="paragraph">
<p>Multiple .NET synchronization primitives derive from the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.waithandle"><code>System.Threading.WaitHandle</code></a> class, which encapsulates a native operating system synchronization handle and uses a <strong>signaling mechanism</strong> for thread interaction.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.mutex"><code>System.Threading.Mutex</code></a>, which grants exclusive access to a shared resource. The state of a mutex is signaled if no thread owns it.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="sql"><span class="n">Mutex</span> <span class="n">mux</span> <span class="o">=</span> <span class="k">new</span><span class="p">();</span>
<span class="nb">int</span> <span class="k">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">Parallel</span><span class="p">.</span><span class="k">For</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">101</span><span class="p">,</span> <span class="n">i</span> <span class="o">=&gt;</span>
<span class="p">{</span>
    <span class="n">mux</span><span class="p">.</span><span class="n">WaitOne</span><span class="p">();</span>
    <span class="n">try</span>
    <span class="p">{</span>
        <span class="k">count</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">finally</span>
    <span class="p">{</span>
        <span class="n">mux</span><span class="p">.</span><span class="n">ReleaseMutex</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="k">Write</span><span class="p">(</span><span class="k">count</span><span class="p">);</span> <span class="o">//</span> <span class="mi">5050</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphore"><code>System.Threading.Semaphore</code></a>, which limits the number of threads that can access a shared resource or a pool of resources concurrently. The state of a semaphore is set to signaled when its count is greater than zero, and nonsignaled when its count is zero.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">Semaphore</span> <span class="n">mux</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">101</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">mux</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">count</span> <span class="p">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="n">mux</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">count</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.eventwaithandle"><code>System.Threading.EventWaitHandle</code></a>, which represents a thread synchronization event and can be either in a signaled (allowing waiting threads to proceed) or unsignaled (blocking waiting threads) state.</p>
<div class="ulist">
<ul>
<li>
<p>An <code>EventWaitHandle</code> created with the <code>EventResetMode.AutoReset</code> flag resets automatically when signaled, after releasing a single waiting thread.</p>
</li>
<li>
<p>An <code>EventWaitHandle</code> created with the <code>EventResetMode.ManualReset</code> flag remains signaled until its <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.eventwaithandle.reset">Reset</a> method is called.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.autoresetevent"><code>System.Threading.AutoResetEvent</code></a>, which derives from <code>EventWaitHandle</code> and, when signaled, resets automatically to an unsignaled state after releasing a single waiting thread.</p>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.manualresetevent"><code>System.Threading.ManualResetEvent</code></a>, which derives from <code>EventWaitHandle</code> and, when signaled, stays in a signaled state until the <code>Reset</code> method is called.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">EventWaitHandle</span> <span class="n">mux</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">EventResetMode</span><span class="p">.</span><span class="n">AutoReset</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">101</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">mux</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">count</span> <span class="p">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="n">mux</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span> <span class="c1">// Sets the state of the event to signaled.</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">count</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>In .NET Framework, because <code>WaitHandle</code> derives from <code>System.MarshalByRefObject</code>, these types can be used to synchronize the activities of threads across application domain boundaries.</p>
</div>
<div class="paragraph">
<p>In .NET Framework, .NET Core, and .NET 5+, some of these types can represent named system synchronization handles, which are visible throughout the operating system and can be used for the inter-process synchronization:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Mutex</p>
</li>
<li>
<p>Semaphore (on Windows)</p>
</li>
<li>
<p>EventWaitHandle (on Windows)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Lightweight synchronization types don&#8217;t rely on underlying operating system handles and typically provide better performance.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>However, they cannot be used for the inter-process synchronization. Use those types for thread synchronization within one application.</p>
</li>
<li>
<p>Some of those types are alternatives to the types derived from <code>WaitHandle</code>.</p>
</li>
<li>
<p>For example, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim"><code>SemaphoreSlim</code></a> is a lightweight alternative to <code>Semaphore</code>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">class</span> <span class="nc">SemaphoreSlim</span> <span class="p">:</span> <span class="n">IDisposable</span>
<span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Semaphore</span> <span class="p">:</span> <span class="n">WaitHandle</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">SemaphoreSlim</span> <span class="n">mux</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">101</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">mux</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">count</span> <span class="p">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="n">mux</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">count</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="synchronization-of-access-to-a-shared-resource">1.7.2. Synchronization of access to a shared resource</h4>
<div class="paragraph">
<p>.NET provides a range of synchronization primitives to control access to a shared resource by multiple threads.</p>
</div>
<div class="sect4">
<h5 id="monitor">1.7.2.1. Monitor</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.monitor">System.Threading.Monitor</a> class grants mutually exclusive access to a shared resource by acquiring or releasing a lock on the object that identifies the resource.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>While a lock is held, the thread that holds the lock can again acquire and release the lock.</p>
</li>
<li>
<p>The <code>Enter</code> method acquires a released lock.</p>
</li>
<li>
<p>The <code>Monitor.TryEnter</code> method can also be used to specify the amount of time during which a thread attempts to acquire a lock.</p>
</li>
<li>
<p>Any other thread is blocked from acquiring the lock and the <code>Monitor.Enter</code> method waits until the lock is released.</p>
</li>
<li>
<p>Because the Monitor class has thread affinity, the thread that acquired a lock must release the lock by calling the <code>Monitor.Exit</code> method.</p>
</li>
<li>
<p>The interaction of threads can be coordinated to acquire a lock on the same object by using the <code>Monitor.Wait</code>, <code>Monitor.Pulse</code>, and <code>Monitor.PulseAll</code> methods.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Use the <code>lock</code> statement in C# and the <code>SyncLock</code> statement in Visual Basic to synchronize access to a shared resource instead of using the <code>Monitor</code> class directly. Those statements are implemented by using the <code>Enter</code> and <code>Exit</code> methods and a <code>try-finally</code> block to ensure that the acquired lock is always released.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">lock</span> <span class="p">(</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Critical section code that only one thread can access at a time</span>
<span class="p">}</span>

<span class="c1">// bool lockTaken = false;</span>
<span class="c1">// try</span>
<span class="c1">// {</span>
<span class="c1">//     Monitor.Enter(obj, ref lockTaken);</span>
<span class="c1">// }</span>
<span class="c1">// finally</span>
<span class="c1">// {</span>
<span class="c1">//     if (lockTaken)</span>
<span class="c1">//     {</span>
<span class="c1">//         Monitor.Exit(obj);</span>
<span class="c1">//     }</span>
<span class="c1">// }</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">ch</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BlockingChannel</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">?&gt;();</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="k">async</span> <span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">200</span><span class="p">);</span>
        <span class="n">ch</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ch</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">v</span> <span class="k">in</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">v</span><span class="p">}</span><span class="s"> "</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">BlockingChannel</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">?&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">T</span><span class="p">?</span> <span class="n">_data</span><span class="p">;</span>
    <span class="k">private</span> <span class="kt">bool</span> <span class="n">_hasData</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">_lockObj</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="n">T</span><span class="p">?</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">_hasData</span><span class="p">)</span> <span class="n">Monitor</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="n">_lockObj</span><span class="p">);</span> <span class="c1">// releases and blocks: conditional variable</span>
            <span class="n">_data</span> <span class="p">=</span> <span class="n">data</span><span class="p">;</span>
            <span class="n">_hasData</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">Monitor</span><span class="p">.</span><span class="nf">Pulse</span><span class="p">(</span><span class="n">_lockObj</span><span class="p">);</span> <span class="c1">// wake one waiting thread on _lockObj: Waiting → Ready</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">T</span><span class="p">?</span> <span class="nf">Read</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">_hasData</span><span class="p">)</span> <span class="n">Monitor</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="n">_lockObj</span><span class="p">);</span> <span class="c1">// conditional variable</span>
            <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="n">_data</span><span class="p">;</span>
            <span class="n">_hasData</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="n">Monitor</span><span class="p">.</span><span class="nf">Pulse</span><span class="p">(</span><span class="n">_lockObj</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">?&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="nf">Read</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
<span class="p">}</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// 0 1 2 3 4 5 6 7 8 9</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="go"><span class="c">// Go</span>
<span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="kt">int</span><span class="p">)</span>
	<span class="k">go</span> <span class="k">func</span><span class="p">(</span><span class="n">ch</span> <span class="k">chan</span><span class="o">&lt;-</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
			<span class="n">ch</span> <span class="o">&lt;-</span> <span class="n">i</span>
		<span class="p">}</span>
		<span class="nb">close</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
	<span class="p">}(</span><span class="n">ch</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ch</span> <span class="p">{</span>
		<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="lock">1.7.2.2. Lock</h5>
<div class="paragraph">
<p>.NET 9 is introducing a new <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.lock">System.Threading.Lock</a> type as a better alternative to existing monitor-based locking.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It is recommended to use the <code>EnterScope</code> method with a language construct that automatically disposes the returned <code>Lock.Scope</code> such as the C# <code>using</code> keyword, or to use the C# <code>lock</code> keyword, as these ensure that the lock is exited in exceptional cases.</p>
</li>
<li>
<p>When using the C# <code>lock</code> keyword or similar to enter and exit a lock, the type of the expression must be precisely <code>System.Threading.Lock</code>.</p>
</li>
<li>
<p>If the type of the expression is anything else, such as <code>Object</code> or a generic type like <code>T</code>, a different implementation that is not interchangeable can be used instead (such as <code>Monitor</code>).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">ExampleDataStructure</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Lock</span> <span class="n">_lockObj</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Modify</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Critical section associated with _lockObj</span>
        <span class="p">}</span>

        <span class="k">using</span> <span class="p">(</span><span class="n">_lockObj</span><span class="p">.</span><span class="nf">EnterScope</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="c1">// Critical section associated with _lockObj</span>
        <span class="p">}</span>

        <span class="n">_lockObj</span><span class="p">.</span><span class="nf">Enter</span><span class="p">();</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="c1">// Critical section associated with _lockObj</span>
        <span class="p">}</span>
        <span class="k">finally</span> <span class="p">{</span> <span class="n">_lockObj</span><span class="p">.</span><span class="nf">Exit</span><span class="p">();</span> <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">_lockObj</span><span class="p">.</span><span class="nf">TryEnter</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="c1">// Critical section associated with _lockObj</span>
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span> <span class="n">_lockObj</span><span class="p">.</span><span class="nf">Exit</span><span class="p">();</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="mutex">1.7.2.3. Mutex</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.mutex">System.Threading.Mutex</a> class, like Monitor, grants exclusive access to a shared resource.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use one of the <code>Mutex.WaitOne</code> method overloads to request the ownership of a mutex.</p>
</li>
<li>
<p>Like Monitor, Mutex has thread affinity and the thread that acquired a mutex must release it by calling the <code>Mutex.ReleaseMutex</code> method.</p>
</li>
<li>
<p>Unlike <code>Monitor</code>, the <code>Mutex</code> class can be used for inter-process synchronization.</p>
<div class="ulist">
<ul>
<li>
<p>To do that, use a <em>named mutex</em>, which is visible throughout the operating system.</p>
</li>
<li>
<p>To create a named mutex instance, use a Mutex constructor that specifies a name.</p>
</li>
<li>
<p>Call the <code>Mutex.OpenExisting</code> method to open an existing named system mutex.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spinlock">1.7.2.4. SpinLock</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.spinlock">System.Threading.SpinLock</a> structure, like Monitor, grants exclusive access to a shared resource based on the availability of a lock.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When SpinLock attempts to acquire a lock that is unavailable, it waits in a loop, repeatedly checking until the lock becomes available.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="n">SpinLock</span> <span class="n">spin</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">101</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">locked</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">spin</span><span class="p">.</span><span class="nf">Enter</span><span class="p">(</span><span class="k">ref</span> <span class="n">locked</span><span class="p">);</span>
        <span class="n">sum</span> <span class="p">+=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">locked</span><span class="p">)</span> <span class="n">spin</span><span class="p">.</span><span class="nf">Exit</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="spinwait">1.7.2.5. SpinWait</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.spinwait">System.Threading.SpinWait</a> is a lightweight synchronization type that you can use in low-level scenarios to avoid the expensive context switches and kernel transitions that are required for kernel events.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>On multicore computers, when a resource is not expected to be held for long periods of time, it can be more efficient for a waiting thread to spin in user mode for a few dozen or a few hundred cycles, and then retry to acquire the resource.</p>
<div class="ulist">
<ul>
<li>
<p>If the resource is available after spinning, then several thousand cycles have been saved.</p>
</li>
<li>
<p>If the resource is still not available, then only a few cycles have been spent and a kernel-based wait can still be entered.</p>
</li>
<li>
<p>The spinning-then-waiting combination is sometimes referred to as a <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/spinwait"><em>two-phase wait operation</em></a>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>On single-processor machines, yields are always used instead of busy waits, and on computers with Intel processors employing Hyper-Threading technology, it helps to prevent hardware thread starvation.</p>
</li>
<li>
<p><code>SpinWait</code> is designed to be used in conjunction with the .NET types that wrap kernel events such as <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.manualresetevent"><code>ManualResetEvent</code></a>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// a two-phase wait operation</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">nums</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">10</span><span class="p">).</span><span class="nf">ToArray</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">latch</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Latch</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">task</span> <span class="p">=</span> <span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEachAsync</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">latch</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]++;</span> <span class="k">return</span> <span class="n">ValueTask</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span> <span class="p">});</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">1_000</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"tick!"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"The door is opening..."</span><span class="p">);</span>
    <span class="n">latch</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="sc">' '</span><span class="p">,</span> <span class="n">nums</span><span class="p">));</span>
<span class="c1">// tick!</span>
<span class="c1">// tick!</span>
<span class="c1">// tick!</span>
<span class="c1">// The door is opening...</span>
<span class="c1">// 1 2 3 4 5 6 7 8 9 10</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">Latch</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Lock</span> <span class="n">_lockObj</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ManualResetEvent</span> <span class="n">_mre</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
    <span class="k">private</span> <span class="kt">bool</span> <span class="n">_state</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Set</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">lock</span> <span class="p">(</span><span class="n">_lockObj</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_state</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">_mre</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Wait</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_state</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">spin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SpinWait</span><span class="p">();</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">_state</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(!</span><span class="n">spin</span><span class="p">.</span><span class="n">NextSpinWillYield</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">spin</span><span class="p">.</span><span class="nf">SpinOnce</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">_mre</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>When performing a spinning operation until a condition is true without a two-phase wait, enabling <code>SpinWait</code> to perform its context switches ensures it behaves responsibly in the Windows operating system environment.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// a lock-free concurrent stack</span>
<span class="k">sealed</span> <span class="k">class</span> <span class="nc">MyConcurrentStack</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">class</span> <span class="nc">Node</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Node</span><span class="p">?</span> <span class="n">Next</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">default</span><span class="p">!;</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="k">volatile</span> <span class="n">Node</span><span class="p">?</span> <span class="n">_head</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">spin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SpinWait</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Node</span> <span class="p">{</span> <span class="n">Value</span> <span class="p">=</span> <span class="n">item</span> <span class="p">};</span>
        <span class="n">Node</span><span class="p">?</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span> <span class="p">=</span> <span class="n">_head</span><span class="p">;</span>
            <span class="n">node</span><span class="p">.</span><span class="n">Next</span> <span class="p">=</span> <span class="n">head</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_head</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">==</span> <span class="n">head</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
            <span class="n">spin</span><span class="p">.</span><span class="nf">SpinOnce</span><span class="p">();</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">spin</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">100</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">spin</span><span class="p">.</span><span class="nf">Reset</span><span class="p">();</span>
                <span class="n">Thread</span><span class="p">.</span><span class="nf">Yield</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TryPop</span><span class="p">(</span><span class="k">out</span> <span class="n">T</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">item</span> <span class="p">=</span> <span class="k">default</span><span class="p">!;</span>
        <span class="kt">var</span> <span class="n">spin</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SpinWait</span><span class="p">();</span>
        <span class="n">Node</span><span class="p">?</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">head</span> <span class="p">=</span> <span class="n">_head</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="k">false</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_head</span><span class="p">,</span> <span class="n">head</span><span class="p">?.</span><span class="n">Next</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">==</span> <span class="n">head</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">item</span> <span class="p">=</span> <span class="n">head</span><span class="p">!.</span><span class="n">Value</span><span class="p">;</span>
                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">spin</span><span class="p">.</span><span class="nf">SpinOnce</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p><code>SpinWait</code> is not generally useful for ordinary applications.</p>
<div class="ulist">
<ul>
<li>
<p>In most cases, the synchronization classes provided by the .NET Framework should be used, such as <code>Monitor</code>.</p>
</li>
<li>
<p>For most purposes where spin waiting is required, however, the <code>SpinWait</code> type should be preferred over the <code>Thread.SpinWait</code> method.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="readerwriterlockslim">1.7.2.6. ReaderWriterLockSlim</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim">System.Threading.ReaderWriterLockSlim</a> class grants exclusive access to a shared resource for writing and allows multiple threads to access the resource simultaneously for reading.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ReaderWriterLockSlim</code> might be used to synchronize access to a shared data structure that supports thread-safe read operations but requires exclusive access to perform write operations.</p>
</li>
<li>
<p>When a thread requests exclusive access (e.g., by calling the <code>EnterWriteLock</code> method), subsequent reader and writer requests block until all existing readers have exited the lock, and the writer has entered and exited the lock.</p>
</li>
<li>
<p>Use <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.readerwriterlockslim.enterupgradeablereadlock">upgradeable mode</a> when a thread usually accesses the resource that is protected  in read mode, but may need to enter write mode if certain conditions are met.</p>
<div class="ulist">
<ul>
<li>
<p>A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</p>
</li>
<li>
<p>Only one thread can enter upgradeable mode at any given time.</p>
</li>
<li>
<p>If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">class</span> <span class="nc">SynchronizedDictionary</span><span class="p">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IDisposable</span> <span class="k">where</span> <span class="n">TKey</span> <span class="p">:</span> <span class="k">notnull</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">&gt;</span> <span class="n">_dictionary</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">TKey</span><span class="p">,</span> <span class="n">TValue</span><span class="p">&gt;();</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ReaderWriterLockSlim</span> <span class="n">_lock</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">ReaderWriterLockSlim</span><span class="p">();</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="n">TKey</span> <span class="n">key</span><span class="p">,</span> <span class="n">TValue</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_lock</span><span class="p">.</span><span class="nf">EnterWriteLock</span><span class="p">();</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="n">_dictionary</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">finally</span> <span class="p">{</span> <span class="n">_lock</span><span class="p">.</span><span class="nf">ExitWriteLock</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">TryAddValue</span><span class="p">(</span><span class="n">TKey</span> <span class="n">key</span><span class="p">,</span> <span class="n">TValue</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_lock</span><span class="p">.</span><span class="nf">EnterUpgradeableReadLock</span><span class="p">();</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_dictionary</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="kt">var</span> <span class="n">res</span><span class="p">)</span> <span class="p">&amp;&amp;</span> <span class="n">res</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">res</span><span class="p">.</span><span class="nf">Equals</span><span class="p">(</span><span class="k">value</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>

            <span class="n">_lock</span><span class="p">.</span><span class="nf">EnterWriteLock</span><span class="p">();</span>
            <span class="k">try</span>
            <span class="p">{</span>
                <span class="n">_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">finally</span> <span class="p">{</span> <span class="n">_lock</span><span class="p">.</span><span class="nf">ExitWriteLock</span><span class="p">();</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">finally</span> <span class="p">{</span> <span class="n">_lock</span><span class="p">.</span><span class="nf">ExitUpgradeableReadLock</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">TryGetValue</span><span class="p">(</span><span class="n">TKey</span> <span class="n">key</span><span class="p">,</span> <span class="p">[</span><span class="nf">MaybeNullWhen</span><span class="p">(</span><span class="k">false</span><span class="p">)]</span> <span class="k">out</span> <span class="n">TValue</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_lock</span><span class="p">.</span><span class="nf">EnterReadLock</span><span class="p">();</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_dictionary</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="k">out</span> <span class="k">value</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">finally</span> <span class="p">{</span> <span class="n">_lock</span><span class="p">.</span><span class="nf">ExitReadLock</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">private</span> <span class="kt">bool</span> <span class="n">_disposed</span><span class="p">;</span>

    <span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">(</span><span class="kt">bool</span> <span class="n">disposing</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(!</span><span class="n">_disposed</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">disposing</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="c1">// perform managed resource cleanup here</span>
                <span class="n">_lock</span><span class="p">.</span><span class="nf">Dispose</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="c1">// perform unmanaged resource cleanup here</span>
            <span class="n">_disposed</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">~</span><span class="nf">SynchronizedDictionary</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="nf">Dispose</span><span class="p">(</span><span class="n">disposing</span><span class="p">:</span> <span class="k">false</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="nf">Dispose</span><span class="p">(</span><span class="n">disposing</span><span class="p">:</span> <span class="k">true</span><span class="p">);</span>
        <span class="n">GC</span><span class="p">.</span><span class="nf">SuppressFinalize</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="semaphore-and-semaphoreslim">1.7.2.7. Semaphore and SemaphoreSlim</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphore">System.Threading.Semaphore</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.semaphoreslim">System.Threading.SemaphoreSlim</a> classes limit the number of threads that can access a shared resource or a pool of resources concurrently.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Additional threads that request the resource wait until any thread releases the semaphore.</p>
</li>
<li>
<p>Because the semaphore doesn&#8217;t have thread affinity, a thread can acquire the semaphore and another one can release it.</p>
</li>
<li>
<p>SemaphoreSlim is a lightweight alternative to Semaphore and can be used only for synchronization within a single process boundary.</p>
</li>
<li>
<p>On Windows, Semaphore can be used for the inter-process synchronization.</p>
</li>
<li>
<p>SemaphoreSlim doesn&#8217;t support named system semaphores.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">ch</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BlockingChannel</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">?&gt;();</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="k">async</span> <span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">10</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">200</span><span class="p">);</span>
        <span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">await</span> <span class="n">ch</span><span class="p">.</span><span class="nf">WriteAsync</span><span class="p">(</span><span class="k">null</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">v</span> <span class="k">in</span> <span class="n">ch</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">v</span><span class="p">}</span><span class="s"> "</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">BlockingChannel</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">?&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">T</span><span class="p">?</span> <span class="n">_data</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">SemaphoreSlim</span> <span class="n">_readSemaphore</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">SemaphoreSlim</span> <span class="n">_writeSemaphore</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">ValueTask</span> <span class="nf">WriteAsync</span><span class="p">(</span><span class="n">T</span><span class="p">?</span> <span class="n">data</span><span class="p">,</span> <span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">_writeSemaphore</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
        <span class="n">cancellationToken</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        <span class="n">_data</span> <span class="p">=</span> <span class="n">data</span><span class="p">;</span>
        <span class="n">_readSemaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="n">T</span><span class="p">?&gt;</span> <span class="nf">ReadAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">_readSemaphore</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
        <span class="n">cancellationToken</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">data</span> <span class="p">=</span> <span class="n">_data</span><span class="p">;</span>
        <span class="n">_writeSemaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">IAsyncEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">?&gt;</span> <span class="nf">GetAsyncEnumerator</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">cancellationToken</span><span class="p">.</span><span class="nf">ThrowIfCancellationRequested</span><span class="p">();</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">await</span> <span class="nf">ReadAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// 0 1 2 3 4 5 6 7 8 9</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Resource Pooling: Limit to 10 connections</span>
<span class="k">private</span> <span class="k">static</span> <span class="n">SemaphoreSlim</span> <span class="n">_connectionSemaphore</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">UseDatabaseConnectionAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Acquire a connection slot</span>
    <span class="k">await</span> <span class="n">_connectionSemaphore</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">();</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// Use the database connection</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="c1">// Release the connection slot</span>
        <span class="n">_connectionSemaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Throttling: Limit to 5 concurrent requests</span>
<span class="k">private</span> <span class="k">static</span> <span class="n">SemaphoreSlim</span> <span class="n">_requestSemaphore</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>

<span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">SendRequestAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Wait for a request slot</span>
    <span class="k">await</span> <span class="n">_requestSemaphore</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">();</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="c1">// Send the request</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="k">finally</span>
    <span class="p">{</span>
        <span class="c1">// Release the request slot</span>
        <span class="n">_requestSemaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="thread-interaction-or-signaling">1.7.3. Thread interaction, or signaling</h4>
<div class="paragraph">
<p>Thread interaction (or thread signaling) means that a thread must wait for notification, or a signal, from one or more threads in order to proceed.</p>
</div>
<div class="sect4">
<h5 id="eventwaithandle">1.7.3.1. EventWaitHandle</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.eventwaithandle">System.Threading.EventWaitHandle</a> class represents a thread synchronization event.</p>
</div>
<div class="paragraph">
<p>A <em>synchronization event</em> can be either in an unsignaled or signaled state.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the state of an event is unsignaled, a thread that calls the event&#8217;s <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.waithandle.waitone"><code>WaitOne</code></a> overload is blocked until an event is signaled.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.eventwaithandle.set"><code>Set</code></a> method sets the state of an event to signaled.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The behavior of an <code>EventWaitHandle</code> that has been signaled depends on its reset mode:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An <code>EventWaitHandle</code> created with the <code>EventResetMode.AutoReset</code> flag resets automatically after releasing a single waiting thread.</p>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s like a turnstile that allows only one thread through each time it&#8217;s signaled.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.autoresetevent">System.Threading.AutoResetEvent</a> class, which derives from <code>EventWaitHandle</code>, represents that behavior.</p>
</li>
</ul>
</div>
</li>
<li>
<p>An <code>EventWaitHandle</code> created with the <code>EventResetMode.ManualReset</code> flag remains signaled until its <code>Reset</code> method is called.</p>
<div class="ulist">
<ul>
<li>
<p>It&#8217;s like a gate that is closed until signaled and then stays open until someone closes it.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.manualresetevent">System.Threading.ManualResetEvent</a> class, which derives from <code>EventWaitHandle</code>, represents that behavior.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.manualreseteventslim">System.Threading.ManualResetEventSlim</a> class is a lightweight alternative to <code>ManualResetEvent</code>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>On Windows, <code>EventWaitHandle</code> can be used for the inter-process synchronization.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To do that, create an <code>EventWaitHandle</code> instance that represents a named system synchronization event by using one of the <code>EventWaitHandle</code> constructors that specifies a name or the <code>EventWaitHandle.OpenExisting</code> method.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Event wait handles are not .NET events. There are no delegates or event handlers involved. The word "event" is used to describe them because they have traditionally been referred to as operating-system events, and because the act of signaling the wait handle indicates to waiting threads that an event has occurred.
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>Event Wait Handles That Reset Automatically <a href="#eventwaithandle">EventWaitHandle</a></p>
<div class="paragraph">
<p>An automatic reset event can be created by specifying <code>EventResetMode.AutoReset</code> when creating the <code>EventWaitHandle</code> object.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As its name implies, this synchronization event resets automatically when signaled, after releasing a single waiting thread.</p>
</li>
<li>
<p>Signal the event by calling its <code>Set</code> method.</p>
</li>
<li>
<p>Automatic reset events are usually used to provide exclusive access to a resource for a single thread at a time.</p>
</li>
<li>
<p>A thread requests the resource by calling the <code>WaitOne</code> method.</p>
</li>
<li>
<p>If no other thread is holding the wait handle, the method returns true and the calling thread has control of the resource.</p>
</li>
<li>
<p>If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it.</p>
</li>
<li>
<p>The event releases the thread and immediately resets, blocking subsequent threads.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Event Wait Handles That Reset Manually <a href="#eventwaithandle">EventWaitHandle</a></p>
<div class="paragraph">
<p>A manual reset event can be created by specifying <code>EventResetMode.ManualReset</code> when creating the <code>EventWaitHandle</code> object.</p>
</div>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>As its name implies, this synchronization event must be reset manually after it has been signaled. Until it is reset, by calling its <code>Reset</code> method, threads that wait on the event handle proceed immediately without blocking.</p>
</li>
<li>
<p>A manual reset event acts like the gate of a corral. When the event is not signaled, threads that wait on it block, like horses in a corral.</p>
</li>
<li>
<p>When the event is signaled, by calling its <code>Set</code> method, all waiting threads are free to proceed. The event remains signaled until its <code>Reset</code> method is called.</p>
</li>
<li>
<p>Like horses leaving a corral, it takes time for the released threads to be scheduled by the operating system and to resume execution.</p>
<div class="ulist">
<ul>
<li>
<p>If the <code>Reset</code> method is called before all the threads have resumed execution, the remaining threads once again block.</p>
</li>
<li>
<p>Which threads resume and which threads block depends on random factors like the load on the system, the number of threads waiting for the scheduler, and so on.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">EventWaitHandle</span> <span class="n">ewh</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">EventWaitHandle</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="n">EventResetMode</span><span class="p">.</span><span class="n">ManualReset</span><span class="p">);</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">ewh</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"FooSingled"</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">ewh</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"BarSingled"</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">ewh</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
<span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// BarSingled</span>
<span class="c1">// FooSingled</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="countdownevent">1.7.3.2. CountdownEvent</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.countdownevent">System.Threading.CountdownEvent</a> class represents an event that becomes set when its count is zero.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>While <code>CountdownEvent.CurrentCount</code> is greater than zero, a thread that calls <code>CountdownEvent.Wait</code> is blocked.</p>
</li>
<li>
<p>Call <code>CountdownEvent.Signal</code> to decrement an event&#8217;s count.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">));</span>
<span class="n">CountdownEvent</span> <span class="n">cde</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">Count</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">Environment</span><span class="p">.</span><span class="n">ProcessorCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">number</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">sum</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
            <span class="n">cde</span><span class="p">.</span><span class="nf">Signal</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="n">cde</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</li>
<li>
<p>In contrast to <code>ManualResetEvent</code> or <code>ManualResetEventSlim</code>, which can be used to unblock multiple threads with a signal from one thread, <code>CountdownEvent</code> can be used to unblock one or more threads with signals from multiple threads.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="barrier">1.7.3.3. Barrier</h5>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.barrier">System.Threading.Barrier</a> class represents a thread execution barrier.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A thread that calls the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.barrier.signalandwait"><code>Barrier.SignalAndWait</code></a> method signals that it reached the barrier and waits until other participant threads reach the barrier.</p>
</li>
<li>
<p>When all participant threads reach the barrier, they proceed and the barrier is reset and can be used again.</p>
</li>
<li>
<p>It might be used when one or more threads require the results of other threads before proceeding to the next computation phase.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">numbers</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">));</span>
<span class="k">using</span> <span class="nn">Barrier</span> <span class="n">barrier</span> <span class="p">=</span> <span class="k">new</span><span class="p">(</span><span class="m">3</span><span class="p">);</span> <span class="c1">// 3 worker threads</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">barrier</span><span class="p">.</span><span class="n">ParticipantCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">number</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">sum</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">barrier</span><span class="p">.</span><span class="nf">SignalAndWait</span><span class="p">();</span> <span class="c1">// Worker threads signal the barrier</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="n">barrier</span><span class="p">.</span><span class="nf">AddParticipant</span><span class="p">();</span> <span class="c1">// main thread</span>
<span class="n">barrier</span><span class="p">.</span><span class="nf">SignalAndWait</span><span class="p">();</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="interlocked">1.7.4. Interlocked</h4>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked">System.Threading.Interlocked</a> class provides static methods that perform simple atomic operations on a variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// bad code: only for demo</span>
<span class="kt">int</span> <span class="n">sum</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">101</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">local</span><span class="p">;</span>
    <span class="k">do</span>
    <span class="p">{</span>
        <span class="n">local</span> <span class="p">=</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="nf">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">sum</span><span class="p">,</span> <span class="n">local</span> <span class="p">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">local</span><span class="p">)</span> <span class="p">!=</span> <span class="n">local</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span> <span class="c1">// 5050</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="the-volatile-keyword">1.8. The volatile keyword</h3>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile"><code>volatile</code></a> keyword indicates that a field might be modified by multiple threads that are executing at the same time. <a href="#language-keywords-volatile">[9]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The compiler, the runtime system, and even hardware may rearrange reads and writes to memory locations for performance reasons.</p>
</li>
<li>
<p>Fields that are declared <code>volatile</code> are excluded from certain kinds of optimizations.</p>
</li>
<li>
<p>There is <strong>no guarantee</strong> of a single total ordering of volatile writes as seen from all threads of execution.</p>
</li>
<li>
<p>On a multiprocessor system:</p>
<div class="ulist">
<ul>
<li>
<p>a volatile read operation does not guarantee to obtain the latest value written to that memory location by any processor.</p>
</li>
<li>
<p>a volatile write operation does not guarantee that the value written would be immediately visible to other processors.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>volatile</code> keyword can only be applied to fields of a class or struct of these types (local variables cannot be declared volatile):</p>
<div class="ulist">
<ul>
<li>
<p>Reference types.</p>
</li>
<li>
<p>Pointer types (in an unsafe context). Note that although the pointer itself can be volatile, the object that it points to cannot. In other words, it cannot declare a "pointer to volatile."</p>
</li>
<li>
<p>Simple types such as <code>sbyte</code>, <code>byte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, <code>uint</code>, <code>char</code>, <code>float</code>, and <code>bool</code>.</p>
</li>
<li>
<p>An <code>enum</code> type with one of the following base types: <code>byte</code>, <code>sbyte</code>, <code>short</code>, <code>ushort</code>, <code>int</code>, or <code>uint</code>.</p>
</li>
<li>
<p>Generic type parameters known to be reference types.</p>
</li>
<li>
<p><code>IntPtr</code> and <code>UIntPtr</code>.</p>
</li>
<li>
<p>Other types, including <code>double</code> and <code>long</code>, cannot be marked volatile because reads and writes to fields of those types cannot be guaranteed to be atomic; for atomic operations, use <code>Interlocked</code> or <code>lock</code> statement.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>volatile</code> keyword makes a best effort to guarantee that the most recent value written by any thread is visible to all other threads immediately.</p>
</div>
<div class="paragraph">
<p>It is typically used as a flag or indicator to let threads poll for changes and make decisions based on the value.</p>
</div>
<div class="paragraph">
<p>It&#8217;s a simple, lightweight way to signal between threads, e.g., to indicate whether a task should stop or proceed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// double-checked locking pattern for thread-safe singleton initialization</span>
<span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Singleton</span>
<span class="p">{</span>
    <span class="c1">// volatile is essential for correct thread safety</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">volatile</span> <span class="n">Singleton</span> <span class="n">_instance</span> <span class="p">=</span> <span class="k">null</span><span class="p">!;</span>

    <span class="c1">// lock object for synchronization</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="kt">object</span> <span class="n">_lock</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>

    <span class="c1">// private constructor to prevent external instantiation</span>
    <span class="k">private</span> <span class="nf">Singleton</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="n">Singleton</span> <span class="n">Instance</span>
    <span class="p">{</span>
        <span class="k">get</span>
        <span class="p">{</span>
            <span class="c1">// read _instance once (non-volatile) for performance</span>
            <span class="n">Singleton</span> <span class="n">result</span> <span class="p">=</span> <span class="n">_instance</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="c1">// first check</span>
            <span class="p">{</span>
                <span class="c1">// synchronize only if the instance is null (reduces contention)</span>
                <span class="k">lock</span> <span class="p">(</span><span class="n">_lock</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="c1">// double-check inside the lock to prevent race conditions</span>
                    <span class="n">result</span> <span class="p">=</span> <span class="n">_instance</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="c1">// second check</span>
                    <span class="p">{</span>
                        <span class="n">_instance</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Singleton</span><span class="p">();</span>
                        <span class="n">result</span> <span class="p">=</span> <span class="n">_instance</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="threadlocalt">1.9. ThreadLocal&lt;T&gt;</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadlocal-1"><code>ThreadLocal&lt;T&gt;</code></a> is a class in C# that provides thread-local storage, meaning each thread gets its own independent instance of a value. It’s especially useful in scenarios where data should be private to each thread, preventing shared access and avoiding synchronization mechanisms like locks or <code>Interlocked</code> for those specific data.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">ThreadLocal</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">sum</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">sum</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">).</span><span class="nf">Sum</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="s">"100:"</span><span class="p">,</span><span class="m">5</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">Value</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">sum</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1_000</span><span class="p">).</span><span class="nf">Sum</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="s">"1000:"</span><span class="p">,</span><span class="m">5</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">Value</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="s">"0:"</span><span class="p">,</span><span class="m">5</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="n">sum</span><span class="p">.</span><span class="n">Value</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
<span class="c1">//    0: 0</span>
<span class="c1">// 1000: 500500</span>
<span class="c1">//  100: 5050</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>A <code>static</code> field marked with <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threadstaticattribute"><code>ThreadStaticAttribute</code></a> is not shared between threads.</p>
<div class="ulist">
<ul>
<li>
<p>Each executing thread has a separate instance of the field, and independently sets and gets values for that field.</p>
</li>
<li>
<p>If the field is accessed on a different thread, it will contain a different value.</p>
</li>
<li>
<p>Do not specify initial values for fields marked with <code>ThreadStaticAttribute</code>, because such initialization occurs only once, when the class constructor executes, and therefore affects only one thread.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">Accumulator</span><span class="p">.</span><span class="nf">A100</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">ThreadPool</span><span class="p">.</span><span class="nf">QueueUserWorkItem</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">Accumulator</span><span class="p">.</span><span class="nf">A1000</span><span class="p">();</span>
<span class="p">});</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">();</span>
<span class="c1">// 1000: 500500</span>
<span class="c1">//  100: 5050</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">Accumulator</span>
<span class="p">{</span>
    <span class="p">[</span><span class="n">ThreadStatic</span><span class="p">]</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">A100</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">100</span><span class="p">).</span><span class="nf">Sum</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="s">"100:"</span><span class="p">,</span><span class="m">5</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="n">sum</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">A1000</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">sum</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1_000</span><span class="p">).</span><span class="nf">Sum</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="s">"1000:"</span><span class="p">,</span><span class="m">5</span><span class="p">}</span><span class="s"> </span><span class="p">{</span><span class="n">sum</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="lazyt">1.10. Lazy&lt;T&gt;</h3>
<div class="ulist">
<ul>
<li>
<p>Use <a href="https://learn.microsoft.com/en-us/dotnet/api/system.lazy-1"><code>Lazy&lt;T&gt;</code></a> to lazy initialization to defer the creation of a large or resource-intensive object, or the execution of a resource-intensive task, particularly when such creation or execution might not occur during the lifetime of the program.</p>
<div class="ulist">
<ul>
<li>
<p>If the lazily initialized object will be accessed by multiple threads, use <code>Lazy&lt;T&gt;()</code> or <code>Lazy&lt;T&gt;(Func&lt;T&gt;)</code> to ensure thread-safety.</p>
</li>
<li>
<p>The default behavior is thread-safe, and only one instance (i.e., a singleton) of the object will be created even if multiple threads try to access it.</p>
<div class="ulist">
<ul>
<li>
<p>In the default mode (<code>ExecutionAndPublication</code>), only one instance is created in the first thread and shared across threads.</p>
</li>
<li>
<p>In <code>PublicationOnly</code> mode, multiple threads may create temporary instances during initialization, but only one instance will be retained and used.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If thread safety is not required, use <code>Lazy&lt;T&gt;(Boolean)</code> with <code>isThreadSafe</code> set to <code>false</code>.</p>
</li>
<li>
<p>If the lazily initialized object does not require additional initialization, use the parameterless constructor <code>Lazy&lt;T&gt;()</code>, otherwise use <code>Lazy&lt;T&gt;(Func&lt;T&gt;)</code> to provide a factory method for initialization.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">sealed</span> <span class="k">class</span> <span class="nc">LargeObject</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">Lazy</span><span class="p">&lt;</span><span class="n">LargeObject</span><span class="p">&gt;</span> <span class="n">s_lazy</span> <span class="p">=</span> <span class="k">new</span><span class="p">(()</span> <span class="p">=&gt;</span>
    <span class="p">{</span>
        <span class="n">Thread</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span> <span class="c1">// lazy</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">LargeObject</span><span class="p">();</span>
    <span class="p">});</span>

    <span class="c1">// singleton</span>
    <span class="k">public</span> <span class="k">static</span> <span class="n">LargeObject</span> <span class="n">Instance</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="n">s_lazy</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"I'm lazy"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="thread-safe-collections">1.11. Thread-safe collections</h3>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> namespace includes several collection classes that are both thread-safe and scalable.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Multiple threads can safely and efficiently add or remove items from these collections, without requiring additional synchronization in user code.</p>
</li>
<li>
<p>When writing new code, use the concurrent collection classes to write multiple threads to the collection concurrently.</p>
</li>
<li>
<p>If only reading from a shared collection, then use the classes in the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic">System.Collections.Generic</a> namespace.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Some of the concurrent collection types use lightweight synchronization mechanisms such as <code>SpinLock</code>, <code>SpinWait</code>, <code>SemaphoreSlim</code>, and <code>CountdownEvent</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>These synchronization types typically use busy spinning for brief periods before they put the thread into a true <code>Wait</code> state.</p>
</li>
<li>
<p>When wait times are expected to be short, spinning is far less computationally expensive than waiting, which involves an expensive kernel transition.</p>
</li>
<li>
<p>For collection classes that use spinning, this efficiency means that multiple threads can add and remove items at a high rate.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ConcurrentQueue&lt;T&gt;</code> and <code>ConcurrentStack&lt;T&gt;</code> classes don&#8217;t use locks at all. Instead, they rely on <code>Interlocked</code> operations to achieve thread safety.</p>
</div>
<div class="paragraph">
<p>The following table lists the collection types in the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent">System.Collections.Concurrent</a> namespace:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 12.5%;">
<col style="width: 87.5%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Type</th>
<th class="tableblock halign-left valign-top">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.blockingcollection-1"><code>BlockingCollection&lt;T&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides bounding and blocking functionality for any type that implements <code>IProducerConsumerCollection&lt;T&gt;</code>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentdictionary-2"><code>ConcurrentDictionary&lt;TKey,TValue&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread-safe implementation of a dictionary of key-value pairs.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentqueue-1"><code>ConcurrentQueue&lt;T&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread-safe implementation of a FIFO (first-in, first-out) queue.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentstack-1"><code>ConcurrentStack&lt;T&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread-safe implementation of a LIFO (last-in, first-out) stack.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.concurrentbag-1"><code>ConcurrentBag&lt;T&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thread-safe implementation of an unordered collection of elements.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.concurrent.iproducerconsumercollection-1"><code>IProducerConsumerCollection&lt;T&gt;</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The interface that a type must implement to be used in a <code>BlockingCollection</code>.</p></td>
</tr>
</tbody>
</table>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p><a href="https://devblogs.microsoft.com/pfxteam/faq-are-all-of-the-new-concurrent-collections-lock-free/">FAQ :: Are all of the new concurrent collections lock-free?</a></p>
</div>
</blockquote>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">What&#8217;s the diff of BlockingCollection&lt;T&gt; and Channel&lt;T&gt; ?</div>
<div class="paragraph">
<p>* <code>BlockingCollection&lt;T&gt;</code> and <code>Channel&lt;T&gt;</code> are both useful for producer/consumer scenarios where one thread or task is producing data and another thread or task is consuming that data. However, their implementation and features are quite different, and they are designed to handle different use-cases.</p>
</div>
<div class="paragraph">
<p><code>BlockingCollection&lt;T&gt;</code> is part of the <code>System.Collections.Concurrent</code> namespace and was introduced in .NET Framework 4.0. It provides a thread-safe, blocking and bounded collection that can be used with multiple producers and consumers.</p>
</div>
<div class="paragraph">
<p>Benefits of <code>BlockingCollection&lt;T&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It simplifies thread communication, as it blocks and waits when trying to add to a full collection or take from an empty one.</p>
</li>
<li>
<p>It provides <code>Add</code> and <code>Take</code> methods for managing the collection, which if bounded, will block if the collection is full or empty, respectively.</p>
</li>
<li>
<p>It implements <code>IEnumerable&lt;T&gt;</code>, allowing easy enumeration of the items in the collection.</p>
</li>
<li>
<p>It has built-in functionality for creating a complete producer/consumer on top of any <code>IProducerConsumerCollection&lt;T&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>Channel&lt;T&gt;</code> is part of the <code>System.Threading.Channels</code> namespace and was introduced in .NET Core 3.0. It&#8217;s newer and designed for the modern .NET threading infrastructure using async and await design patterns. <a href="#an-introduction-to-system-threading-channels">[8]</a></p>
</div>
<div class="paragraph">
<p>Benefits of <code>Channel&lt;T&gt;</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It supports the async programming model and can be used with <code>async</code> and <code>await</code> keywords in C#.</p>
</li>
<li>
<p>It is designed for scenarios where you have asynchronous data streams that need to be processed.</p>
</li>
<li>
<p>It provides both synchronous and asynchronous methods for adding (<code>Writer.TryWrite</code>, <code>Writer.WriteAsync</code>) and receiving (<code>Reader.TryRead</code>, <code>Reader.ReadAsync</code>) data.</p>
</li>
<li>
<p>It supports back pressure by naturally making the producer wait if the channel is full.</p>
</li>
<li>
<p>It allows for creating unbounded or bounded channels via <code>Channel.CreateUnbounded&lt;T&gt;</code> and <code>Channel.CreateBounded&lt;T&gt;</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In general, <code>Channel&lt;T&gt;</code> is more modern and better integrated with async programming model. Therefore, for newer applications it is recommended to use the <code>Channel&lt;T&gt;</code> class.</p>
</div>
<div class="paragraph">
<p>However, if you have a legacy application where you cannot use async and await extensively, or where you are using ThreadPool and Tasks heavily, then <code>BlockingCollection&lt;T&gt;</code> might be a better choice.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="asynchronous-programming">2. Asynchronous programming</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The core of async programming is the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task"><code>Task</code></a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task"><code>Task&lt;T&gt;</code></a> objects, which model asynchronous operations. They are supported by the <code>async</code> and <code>await</code> keywords. The model is fairly simple in most cases: <a href="#async-scenarios">[30]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>For I/O-bound code, <code>await</code> an operation that returns a <code>Task</code> or <code>Task&lt;T&gt;</code> inside of an <code>async</code> method.</p>
<div class="ulist">
<ul>
<li>
<p>If the code is waiting for something (e.g., data from a database), it is I/O-bound.</p>
</li>
<li>
<p>Use <code>async</code> and <code>await</code> without <code>Task.Run</code> or the Task Parallel Library.</p>
</li>
</ul>
</div>
</li>
<li>
<p>For CPU-bound code, <code>await</code> an operation that is started on a background thread with the <code>Task.Run</code> method.</p>
<div class="ulist">
<ul>
<li>
<p>If the code is performing heavy computation, it is CPU-bound.</p>
</li>
<li>
<p>Use <code>async</code> and <code>await</code>, but offload the work to another thread using <code>Task.Run</code> for responsiveness.</p>
</li>
<li>
<p>If the task is suitable for parallelism, consider the Task Parallel Library.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>await</code> keyword is where the magic happens that yields control to the caller of the method that performed <code>await</code>, and it ultimately allows a UI to be responsive or a service to be elastic.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>.NET provides three patterns for performing asynchronous operations: <a href="#bib-asynchronous-programming-patterns">[10]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Task-based Asynchronous Pattern (TAP)</strong>, which uses a single method to represent the initiation and completion of an asynchronous operation.</p>
<div class="ulist">
<ul>
<li>
<p>TAP was introduced in .NET Framework 4.</p>
</li>
<li>
<p>It&#8217;s the recommended approach to asynchronous programming in .NET.</p>
</li>
<li>
<p>The <code>async</code> and <code>await</code> keywords in C# and the <code>Async</code> and <code>Await</code> operators in Visual Basic add language support for TAP.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">string</span> <span class="n">hostname</span> <span class="p">=</span> <span class="s">"asp.net"</span><span class="p">;</span>
<span class="n">IPAddress</span><span class="p">[]</span> <span class="n">addrs</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Dns</span><span class="p">.</span><span class="nf">GetHostAddressesAsync</span><span class="p">(</span><span class="n">hostname</span><span class="p">);</span>
<span class="c1">// Avoids blocking the current thread while waiting for the operation to complete</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span> <span class="c1">// 40.118.185.161</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>Event-based Asynchronous Pattern (EAP)</code>, which is the event-based legacy model for providing asynchronous behavior.</p>
<div class="ulist">
<ul>
<li>
<p>It requires a method that has the <code>Async</code> suffix and one or more events, event handler delegate types, and EventArg-derived types.</p>
</li>
<li>
<p>EAP was introduced in .NET Framework 2.0.</p>
</li>
<li>
<p>It&#8217;s no longer recommended for new development.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">WebClient</span> <span class="n">http</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span>
<span class="n">http</span><span class="p">.</span><span class="n">DownloadStringCompleted</span> <span class="p">+=</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Error</span><span class="p">.</span><span class="n">Message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">Result</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span> <span class="c1">// vary, e.g., 247965</span>
<span class="p">};</span>
<span class="n">http</span><span class="p">.</span><span class="nf">DownloadStringAsync</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="s">"https://asp.net"</span><span class="p">));</span>
<span class="c1">// Avoids blocking the current thread while waiting for the operation to complete</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">ReadKey</span><span class="p">();</span>  <span class="c1">// Wait for the HTTP operation to complete</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Asynchronous Programming Model (APM)</code> pattern (also called the IAsyncResult pattern), which is the legacy model that uses the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.iasyncresult"><code>IAsyncResult</code></a> interface to provide asynchronous behavior.</p>
<div class="ulist">
<ul>
<li>
<p>In this pattern, asynchronous operations require <code>Begin</code> and <code>End</code> methods (for example, <code>BeginWrite</code> and <code>EndWrite</code> to implement an asynchronous write operation).</p>
</li>
<li>
<p>This pattern is no longer recommended for new development.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">string</span> <span class="n">hostname</span> <span class="p">=</span> <span class="s">"asp.net"</span><span class="p">;</span>
<span class="n">IAsyncResult</span> <span class="n">ar</span> <span class="p">=</span> <span class="n">Dns</span><span class="p">.</span><span class="nf">BeginGetHostAddresses</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
<span class="c1">// Avoids blocking the current thread while waiting for the operation to complete</span>
<span class="n">IPAddress</span><span class="p">[]</span> <span class="n">addrs</span> <span class="p">=</span> <span class="n">Dns</span><span class="p">.</span><span class="nf">EndGetHostAddresses</span><span class="p">(</span><span class="n">ar</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">addrs</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span> <span class="c1">// 40.118.185.161</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="tasks-and-valuetasks">2.1. Tasks and ValueTasks</h3>
<div class="paragraph">
<p>In .NET Framework 4.0, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task"><code>Task</code></a> type was introduced the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks">System.Threading.Tasks</a>. <a href="#how-async-await-really-works">[17]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>At its heart, a <code>Task</code> is just a data structure that represents the eventual completion of some asynchronous operation (other frameworks call a similar type a “promise” or a “future”).</p>
</li>
<li>
<p>A <code>Task</code> is created to represent some operation, and then when the operation it logically represents completes, the results are stored into that <code>Task</code>.</p>
</li>
<li>
<p>Unlike <code>IAsyncResult</code>, <code>Task</code> supports built-in continuations, enabling asynchronous callbacks to execute reliably whether the task is completed, not yet completed, or completing concurrently with the notification request.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">class</span> <span class="nc">MyTask</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">bool</span> <span class="n">_completed</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Exception</span><span class="p">?</span> <span class="n">_exception</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">MyTask</span><span class="p">&gt;?</span> <span class="n">_continuation</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">ExecutionContext</span><span class="p">?</span> <span class="n">_context</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">struct</span> <span class="nc">Awaiter</span><span class="p">(</span><span class="n">MyTask</span> <span class="n">t</span><span class="p">)</span> <span class="p">:</span> <span class="n">INotifyCompletion</span>
    <span class="p">{</span>
      <span class="k">public</span> <span class="n">Awaiter</span> <span class="nf">GetAwaiter</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">this</span><span class="p">;</span>

      <span class="k">public</span> <span class="kt">bool</span> <span class="n">IsCompleted</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="n">IsCompleted</span><span class="p">;</span>

      <span class="k">public</span> <span class="k">void</span> <span class="nf">OnCompleted</span><span class="p">(</span><span class="n">Action</span> <span class="n">continuation</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">continuation</span><span class="p">);</span>

      <span class="k">public</span> <span class="k">void</span> <span class="nf">GetResult</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">t</span><span class="p">.</span><span class="nf">Wait</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">Awaiter</span> <span class="nf">GetAwaiter</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">Awaiter</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.valuetask"><code>ValueTask&lt;TResult&gt;</code></a> was introduced in .NET Core 2.0 as a struct capable of wrapping either a <code>TResult</code> or a <code>Task&lt;TResult&gt;</code>.</p>
</li>
<li>
<p>Only if performance analysis proves it worthwhile should a <code>ValueTask</code> be used instead of a <code>Task</code>. <a href="#understanding-the-whys-whats-and-whens-of-valuetask">[28]</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">readonly</span> <span class="k">struct</span> <span class="nc">ValueTask</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span>
<span class="p">{</span>
   <span class="k">private</span> <span class="k">readonly</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;?</span> <span class="n">_task</span><span class="p">;</span>
   <span class="k">private</span> <span class="k">readonly</span> <span class="n">TResult</span> <span class="n">_result</span><span class="p">;</span>
   <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/fundamentals/runtime-libraries/system-threading-tasks-taskscheduler">default task scheduler</a> provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance, which should be sufficient for most scenarios.</p>
</li>
<li>
<p>In .NET Framework 4.5, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task.run"><code>Task.Run</code></a> was introduced as a simpler alternative to <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.taskfactory.startnew"><code>Task.Factory.StartNew</code></a> for common scenarios of offloading work to the thread pool. <a href="#task-run-vs-task-factory-startnew">[29]</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">someAction</span><span class="p">);</span>

<span class="c1">// equivalent to:</span>

<span class="n">Task</span><span class="p">.</span><span class="n">Factory</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">(</span><span class="n">someAction</span><span class="p">,</span>
    <span class="n">CancellationToken</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">TaskCreationOptions</span><span class="p">.</span><span class="n">DenyChildAttach</span><span class="p">,</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="executioncontext-and-synchronizationcontext">2.2. ExecutionContext and SynchronizationContext</h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.executioncontext"><code>ExecutionContext</code></a> is a state bag that holds ambient information about the current execution environment or context to capture all of this state from one thread and then restore it onto another thread while the logical flow of control continues. <a href="#executioncontext-vs-synchronizationcontext">[27]</a></p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// ambient state captured into ec</span>
<span class="n">ExecutionContext</span> <span class="n">ec</span> <span class="p">=</span> <span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">Capture</span><span class="p">();</span>

<span class="c1">// restored during the invocation of a delegate</span>
<span class="n">ExecutionContext</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="n">ec</span><span class="p">,</span> <span class="k">delegate</span>
<span class="p">{</span>
    <span class="c1">// code here will see ec’s state as ambient</span>
<span class="p">},</span> <span class="k">null</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p><a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext"><code>SynchronizationContext</code></a> was also introduced in .NET Framework 2.0, as an abstraction for a general scheduler.i <a href="#how-async-await-really-works">[17]</a></p>
<div class="ulist">
<ul>
<li>
<p>In particular, SynchronizationContext‘s most used method is <code>Post</code>, which queues a work item to whatever scheduler is represented by that context.</p>
</li>
<li>
<p>The base implementation of <code>SynchronizationContext</code>, for example, just represents the <code>ThreadPool</code>, and so the base implementation of <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext.post"><code>SynchronizationContext.Post</code></a> simply delegates to <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool.queueuserworkitem"><code>ThreadPool.QueueUserWorkItem</code></a>, which is used to ask the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool"><code>ThreadPool</code></a> to invoke the supplied callback with the associated state on one the pool’s threads.</p>
</li>
<li>
<p>However, SynchronizationContext‘s bread-and-butter isn’t just about supporting arbitrary schedulers, rather it’s about supporting scheduling in a manner that works according to the needs of various application models.</p>
<div class="ulist">
<ul>
<li>
<p>WinForms provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.windowsformssynchronizationcontext"><code>WindowsFormSynchronizationContext</code></a> type which overrides <code>Post</code> to call <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.forms.control.begininvoke"><code>Control.BeginInvoke</code></a>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">WindowsFormsSynchronizationContext</span> <span class="p">:</span> <span class="n">SynchronizationContext</span><span class="p">,</span> <span class="n">IDisposable</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Post</span><span class="p">(</span><span class="n">SendOrPostCallback</span> <span class="n">d</span><span class="p">,</span> <span class="kt">object</span><span class="p">?</span> <span class="n">state</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="n">_controlToSendTo</span><span class="p">?.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="k">new</span> <span class="kt">object</span><span class="p">?[]</span> <span class="p">{</span> <span class="n">state</span> <span class="p">});</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>WPF provides the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatchersynchronizationcontext"><code>DispatcherSynchronizationContext</code></a> type which overrides <code>Post</code> to call <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher.begininvoke"><code>Dispatcher.BeginInvoke</code></a>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">DispatcherSynchronizationContext</span> <span class="p">:</span> <span class="n">SynchronizationContext</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">Post</span><span class="p">(</span><span class="n">SendOrPostCallback</span> <span class="n">d</span><span class="p">,</span> <span class="n">Object</span> <span class="n">state</span><span class="p">)</span> <span class="p">=&gt;</span>
        <span class="n">_dispatcher</span><span class="p">.</span><span class="nf">BeginInvoke</span><span class="p">(</span><span class="n">_priority</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">state</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="asynclocalt">2.3. AsyncLocal&lt;T&gt;</h3>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.asynclocal-1">AsyncLocal&lt;T&gt;</a> class represents ambient data that is local to a given asynchronous control flow, such as an asynchronous method.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Because the task-based asynchronous programming model tends to abstract the use of threads, the <code>AsyncLocal&lt;T&gt;</code> designed to flow with the asynchronous logical operation to persist data across threads.</p>
</li>
<li>
<p>A continuation task created with <code>ContinueWith</code> is considered a separate and independent task, even if it&#8217;s attached to the original task, which is not part of the same logical asynchronous operation that <code>AsyncLocal</code> tracks.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">ThreadLocal</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">_threadLocal</span> <span class="p">=</span> <span class="k">new</span><span class="p">();</span> <span class="c1">// for per-thread data</span>
<span class="n">AsyncLocal</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">_asyncLocal</span>   <span class="p">=</span> <span class="k">new</span><span class="p">();</span> <span class="c1">// for per-async-flow data</span>

<span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="k">async</span> <span class="p">()</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">_threadLocal</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="s">"Thread Local Value 1"</span><span class="p">;</span>
    <span class="n">_asyncLocal</span><span class="p">.</span><span class="n">Value</span> <span class="p">=</span> <span class="s">"Async Local Value 1"</span><span class="p">;</span>
    <span class="nf">PrintValues</span><span class="p">(</span><span class="m">1</span><span class="p">);</span>

    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>

    <span class="nf">PrintValues</span><span class="p">(</span><span class="m">2</span><span class="p">);</span>
    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">PrintValues</span><span class="p">(</span><span class="m">3</span><span class="p">));</span>
<span class="p">}).</span><span class="nf">ContinueWith</span><span class="p">(</span><span class="n">_</span> <span class="p">=&gt;</span> <span class="nf">PrintValues</span><span class="p">(</span><span class="m">4</span><span class="p">));</span>

<span class="nf">PrintValues</span><span class="p">(</span><span class="m">5</span><span class="p">);</span>

<span class="k">void</span> <span class="nf">PrintValues</span><span class="p">(</span><span class="kt">int</span> <span class="n">point</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span>
        <span class="s">$"[</span><span class="p">{</span><span class="n">point</span><span class="p">}</span><span class="s">] "</span> <span class="p">+</span>
        <span class="s">$"[Task: </span><span class="p">{</span><span class="n">Task</span><span class="p">.</span><span class="n">CurrentId</span><span class="p">,</span><span class="m">1</span><span class="p">}</span><span class="s">] "</span> <span class="p">+</span>
        <span class="s">$"[Thread: </span><span class="p">{</span><span class="n">Environment</span><span class="p">.</span><span class="n">CurrentManagedThreadId</span><span class="p">,</span><span class="m">1</span><span class="p">}</span><span class="s">] "</span> <span class="p">+</span>
        <span class="s">$"[ThreadLocal: </span><span class="p">{</span><span class="n">_threadLocal</span><span class="p">.</span><span class="n">Value</span><span class="p">}</span><span class="s">] "</span> <span class="p">+</span>
        <span class="s">$"[AsyncLocal: </span><span class="p">{</span><span class="n">_asyncLocal</span><span class="p">.</span><span class="n">Value</span><span class="p">}</span><span class="s">]"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="console"><span class="gp">$</span><span class="w"> </span>dotnet run
<span class="go">[1] [Task: 1] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: Async Local Value 1]
[2] [Task:  ] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: Async Local Value 1]
[3] [Task: 2] [Thread: 6] [ThreadLocal: ] [AsyncLocal: Async Local Value 1]
[4] [Task: 3] [Thread: 6] [ThreadLocal: ] [AsyncLocal: ]
[5] [Task:  ] [Thread: 6] [ThreadLocal: ] [AsyncLocal: ]
</span><span class="gp">$</span><span class="w"> </span>dotnet run
<span class="go">[1] [Task: 1] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: Async Local Value 1]
[2] [Task:  ] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: Async Local Value 1]
[3] [Task: 2] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: Async Local Value 1]
[4] [Task: 3] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: ]
[5] [Task:  ] [Thread: 4] [ThreadLocal: Thread Local Value 1] [AsyncLocal: ]</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="wpf-threading-model">2.4. WPF threading model</h3>
<div class="paragraph">
<p>Typically, WPF applications start with two threads: one for handling rendering and another for managing the UI. <a href="#wpf-advanced-threading-model">[11]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The rendering thread effectively runs hidden in the background while the UI thread receives input, handles events, paints the screen, and runs application code.</p>
</li>
<li>
<p>Most applications use a single UI thread, although in some situations it is best to use several.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The UI thread queues work items inside an object called a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a> selects work items on a priority basis and runs each one to completion.</p>
</li>
<li>
<p>Every UI thread must have at least one <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a>, and each <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a> can execute work items in exactly one thread.</p>
</li>
<li>
<p>The trick to building responsive, user-friendly applications is to maximize the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a> throughput by keeping the work items small.</p>
</li>
<li>
<p>A background thread can ask the UI thread to perform an operation on its behalf by registering a work item with the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a> of the UI thread.</p>
</li>
<li>
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher">Dispatcher</a> class provides the methods for registering work items: <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher.invokeasync"><code>Dispatcher.InvokeAsync</code></a>, <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher.begininvoke"><code>Dispatcher.BeginInvoke</code></a>, and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.windows.threading.dispatcher.invoke"><code>Dispatcher.Invoke</code></a> to schedule a delegate for execution.</p>
<div class="ulist">
<ul>
<li>
<p><code>Invoke</code> is a synchronous call – that is, it doesn&#8217;t return until the UI thread actually finishes executing the delegate.</p>
</li>
<li>
<p><code>InvokeAsync</code> and <code>BeginInvoke</code> are asynchronous and return immediately.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="the-async-and-await-keywords">2.5. The async and await keywords</h3>
<div class="paragraph">
<p>Asynchronous programming can help avoid performance bottlenecks and enhance the overall responsiveness of an application. However, traditional techniques for writing asynchronous applications can be complicated, making them difficult to write, debug, and maintain.</p>
</div>
<div class="paragraph">
<p>C# supports simplified approach, async programming, that leverages asynchronous support in the .NET runtime to let the compiler does the difficult work that the developer used to do, and the application retains a logical structure that resembles synchronous code. <a href="#task-asynchronous-programming-model">[16]</a></p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/media/task-asynchronous-programming-model/navigation-trace-async-program.png#lightbox" alt="Trace navigation of async control flow" width="55%" height="55%">
</div>
</div>
<div class="paragraph">
<p>Asynchrony is essential for activities that are potentially blocking, such as web access.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Access to a web resource sometimes is slow or delayed.</p>
</li>
<li>
<p>If such an activity is blocked in a synchronous process, the entire application must wait.</p>
</li>
<li>
<p>In an asynchronous process, the application can continue with other work that doesn&#8217;t depend on the web resource until the potentially blocking task finishes.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Asynchrony proves especially valuable for applications that access the UI thread because all UI-related activity usually shares one thread.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If any process is blocked in a synchronous application, all are blocked, and the application stops responding, and the user might conclude that it has failed when instead it&#8217;s just waiting.</p>
</li>
<li>
<p>When using asynchronous methods, the application continues to respond to the UI, and allow the user to resize or minimize a window, for example, or close the application if there’s no desire to wait for it to finish.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Async methods are intended to be non-blocking operations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>An await expression in an async method doesn&#8217;t block the current thread while the awaited task is running.</p>
</li>
<li>
<p>Instead, the expression signs up the rest of the method as a continuation and returns control to the caller of the async method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>async</code> and <code>await</code> keywords don&#8217;t cause additional threads to be created.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Async methods don&#8217;t require multithreading because an async method doesn&#8217;t run on its own thread. The method runs on the current synchronization context and uses time on the thread only when the method is active.</p>
</li>
<li>
<p>Use <code>Task.Run</code> to move CPU-bound work to a background thread, but a background thread doesn&#8217;t speed up the process of waiting because the process itself is inherently waiting for some external result, not doing any computation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the <code>async</code> modifier is used to specify that a method is an async method, it enables the following two capabilities.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The marked async method can use <code>await</code> to designate suspension points.</p>
<div class="ulist">
<ul>
<li>
<p>The <code>await</code> operator tells the compiler that the async method can&#8217;t continue past that point until the awaited asynchronous process is complete.</p>
</li>
<li>
<p>In the meantime, control returns to the caller of the async method.</p>
</li>
<li>
<p>The suspension of an async method at an await expression doesn&#8217;t constitute an exit from the method, and finally blocks don&#8217;t run.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The marked async method can itself be awaited by methods that call it.</p>
</li>
<li>
<p>An async method typically contains one or more occurrences of an await operator, but the absence of await expressions doesn&#8217;t cause a compiler error.</p>
<div class="ulist">
<ul>
<li>
<p>If an async method doesn&#8217;t use an <code>await</code> operator to mark a suspension point, the method executes as a synchronous method does, despite the <code>async</code> modifier.</p>
</li>
<li>
<p>The compiler issues a warning for such methods.</p>
</li>
</ul>
</div>
</li>
<li>
<p>An async method can also have a <code>void</code> return type that is used primarily to define event handlers, where a <code>void</code> return type is required. <a href="#task-asynchronous-programming-model">[16]</a></p>
<div class="ulist">
<ul>
<li>
<p>Async event handlers often serve as the starting point for async programs.</p>
</li>
<li>
<p>An async method that has a <code>void</code> return type can&#8217;t be awaited, and the caller of a void-returning method can&#8217;t catch any exceptions that the method throws</p>
</li>
<li>
<p>An async method can&#8217;t declare <code>in</code>, <code>ref</code> or <code>out</code> parameters, but the method can call methods that have such parameters.</p>
</li>
<li>
<p>Similarly, an async method can&#8217;t return a value by reference, although it can call methods with <code>ref</code> return values.</p>
</li>
</ul>
</div>
</li>
<li>
<p>An async method might <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-return-types">return an async stream</a>, represented by <code>IAsyncEnumerable&lt;T&gt;</code> that provides a way to enumerate items read from a stream when elements are generated in chunks with repeated asynchronous calls.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">word</span> <span class="k">in</span> <span class="nf">ReadWordsFromStreamAsync</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">async</span> <span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">ReadWordsFromStreamAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">string</span> <span class="n">data</span> <span class="p">=</span>
        <span class="s">@"This is a line of text.
              Here is the second line of text.
              And there is one more for good measure.
              Wait, that was the penultimate line."</span><span class="p">;</span>

    <span class="k">using</span> <span class="nn">var</span> <span class="n">readStream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StringReader</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>

    <span class="kt">string</span><span class="p">?</span> <span class="n">line</span> <span class="p">=</span> <span class="k">await</span> <span class="n">readStream</span><span class="p">.</span><span class="nf">ReadLineAsync</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">line</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">word</span> <span class="k">in</span> <span class="n">line</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="sc">' '</span><span class="p">,</span> <span class="n">StringSplitOptions</span><span class="p">.</span><span class="n">RemoveEmptyEntries</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">word</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">line</span> <span class="p">=</span> <span class="k">await</span> <span class="n">readStream</span><span class="p">.</span><span class="nf">ReadLineAsync</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="task-configureawait">2.6. Task.ConfigureAwait</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
Don’t Need <code>ConfigureAwait(false)</code>, But Still Use It in Libraries. <a href="#stephencleary-aspnetcore-synchronization-context">[22]</a>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When an asynchronous method awaits a <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.task"><code>Task</code></a> directly, continuation usually occurs in the same thread that created the task, depending on the async context.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>SynchronizationContext</code> makes it possible to call reusable helpers and automatically be scheduled back whenever and to wherever the calling environment deems fit.</p>
</li>
<li>
<p>As a result, it&#8217;s natural to expect that to "just work" with async/await, and it does.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="n">button1</span><span class="p">.</span><span class="n">Text</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="nf">ComputeMessage</span><span class="p">());</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>That invocation of <code>ComputeMessage</code> is offloaded to the thread pool, and upon the method&#8217;s completion, execution transitions back to the UI thread associated with the button, and the setting of its <code>Text</code> property happens on that thread.</p>
</li>
</ul>
</div>
</li>
<li>
<p>That integration with <code>SynchronizationContext</code> is left up to the <em>awaiter</em> implementation to be responsible for actually invoking or queueing the supplied continuation when the represented asynchronous operation completes. <a href="#configureawait-faq">[18]</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>ConfigureAwait</code> method is simply a method that returns a struct (a <code>ConfiguredTaskAwaitable</code>) that wraps the original task it was called on as well as the specified <code>Boolean</code> value.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ConfigureAwait(continueOnCapturedContext: false)</code> is used to avoid forcing the callback to be invoked on the original context or scheduler to improve performance by avoiding unnecessary context switches.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">object</span> <span class="n">scheduler</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">continueOnCapturedContext</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">scheduler</span> <span class="p">=</span> <span class="n">SynchronizationContext</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">scheduler</span> <span class="k">is</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Current</span> <span class="p">!=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Default</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">scheduler</span> <span class="p">=</span> <span class="n">TaskScheduler</span><span class="p">.</span><span class="n">Current</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
<li>
<p>Use <code>ConfigureAwait(false)</code> when the continuation does not need to be run on the original context, such as in background worker threads or library code where context is not important.</p>
</li>
<li>
<p>Using <code>ConfigureAwait(false)</code> can help avoid deadlocks in certain scenarios, especially in UI-based applications where the main thread is waiting for an async task to complete while the continuation is trying to marshal back to the same thread.</p>
</li>
<li>
<p>It is recommended to use <code>ConfigureAwait(false)</code> in library code or when performing I/O-bound work unless the continuation explicitly requires a UI or thread-specific context.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="system-threading-channels">2.7. System.Threading.Channels</h3>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels">System.Threading.Channels</a> namespace provides a set of synchronization data structures for passing data between producers and consumers asynchronously via a FIFO queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">MySimpleChannel</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_queue</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ConcurrentQueue</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">SemaphoreSlim</span> <span class="n">_semaphore</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SemaphoreSlim</span><span class="p">(</span><span class="m">0</span><span class="p">);</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Write</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_queue</span><span class="p">.</span><span class="nf">Enqueue</span><span class="p">(</span><span class="k">value</span><span class="p">);</span> <span class="c1">// store the data</span>
        <span class="n">_semaphore</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span> <span class="c1">// notify any consumers that more data is available</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">async</span> <span class="n">ValueTask</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">ReadAsync</span><span class="p">(</span><span class="n">CancellationToken</span> <span class="n">cancellationToken</span> <span class="p">=</span> <span class="k">default</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">await</span> <span class="n">_semaphore</span><span class="p">.</span><span class="nf">WaitAsync</span><span class="p">(</span><span class="n">cancellationToken</span><span class="p">).</span><span class="nf">ConfigureAwait</span><span class="p">(</span><span class="k">false</span><span class="p">);</span> <span class="c1">// wait</span>
        <span class="kt">bool</span> <span class="n">gotOne</span> <span class="p">=</span> <span class="n">_queue</span><span class="p">.</span><span class="nf">TryDequeue</span><span class="p">(</span><span class="k">out</span> <span class="n">T</span> <span class="n">item</span><span class="p">);</span> <span class="c1">// retrieve the data</span>
        <span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">gotOne</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>A channel is simply a data structure that’s used to store produced data for a consumer to retrieve, and an appropriate synchronization to enable that to happen safely, while also enabling appropriate notifications in both directions. <a href="#an-introduction-to-system-threading-channels">[8]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>To create a channel that specifies a maximum capacity, call <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.createbounded"><code>Channel.CreateBounded</code></a>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">channel</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateBounded</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="m">7</span><span class="p">);</span></code></pre>
</div>
</div>
</li>
<li>
<p>To create a channel that is used by any number of readers and writers concurrently, call <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.createunbounded"><code>Channel.CreateUnbounded</code></a>.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">channel</span> <span class="p">=</span> <span class="n">Channel</span><span class="p">.</span><span class="n">CreateUnbounded</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;();</span></code></pre>
</div>
</div>
</li>
<li>
<p>Each bounding strategy exposes various creator-defined options, either <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.boundedchanneloptions"><code>BoundedChannelOptions</code></a> or <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.channels.unboundedchanneloptions"><code>UnboundedChannelOptions</code></a> respectively.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="parallel-programming-in-net">3. Parallel programming in .NET</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Many personal computers and workstations have multiple CPU cores that enable multiple threads to be executed simultaneously. To take advantage of the hardware, parallelizing code can distribute work across multiple processors. <a href="#bib-parallel-programming">[13]</a></p>
</div>
<div class="paragraph">
<p>The following illustration provides a high-level overview of the parallel programming architecture in .NET.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/media/tpl-architecture.png" alt=".NET Parallel Programming Architecture" width="55%" height="55%">
</div>
</div>
<div class="sect2">
<h3 id="task-parallel-library-tpl">3.1. Task Parallel Library (TPL)</h3>
<div class="paragraph">
<p>The Task Parallel Library (TPL) is a set of public types and APIs in the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading">System.Threading</a> and <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks">System.Threading.Tasks</a> namespaces.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The purpose of the TPL is to make developers more productive by simplifying the process of adding <strong>parallelism</strong> and <strong>concurrency</strong> to applications.</p>
</li>
<li>
<p>The TPL dynamically scales the degree of concurrency to use all the available processors most efficiently.</p>
</li>
<li>
<p>In addition, the TPL handles the partitioning of the work, the scheduling of threads on the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.threadpool">ThreadPool</a>, cancellation support, state management, and other low-level details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In .NET Framework 4, the TPL is the preferred way to write multithreaded and parallel code, but not all code is suitable for parallelization.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>For example, if a loop performs only a small amount of work on each iteration, or it doesn&#8217;t run for many iterations, then the overhead of parallelization can cause the code to run more slowly.</p>
</li>
<li>
<p>Parallelization adds complexity to program execution, so a basic understanding of threading concepts like locks, deadlocks, and race conditions is recommended to use the TPL effectively.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="data-parallelism">3.2. Data Parallelism</h3>
<div class="paragraph">
<p><em>Data parallelism</em> refers to scenarios in which the same operation is performed concurrently (that is, in parallel) on elements in a source collection or array. <a href="#bib-data-parallelism-task-parallel-library">[14]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>In data parallel operations, the source collection is partitioned so that multiple threads can operate on different segments concurrently.</p>
</li>
<li>
<p>The Task Parallel Library (TPL) supports data parallelism through the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.parallel">System.Threading.Tasks.Parallel</a> class that provides method-based parallel implementations of <code>for</code> and <code>foreach</code> loops.</p>
</li>
<li>
<p>Both <code>ForEach</code>/<code>For</code> and <code>ForEachAsync</code>/<code>ForAsync</code> use the thread pool to distribute work across multiple threads for parallelism, but async versions are optimized for I/O-bound operations by allowing threads to be released during I/O waits.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">// Executes a for loop in which iterations may run in parallel.</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">For</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="n">i</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">});</span>
<span class="k">await</span> <span class="n">Parallel</span><span class="p">.</span><span class="nf">ForAsync</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ValueTask</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Executes a foreach operation in which iterations may run in parallel.</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">),</span> <span class="n">num</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">});</span>
<span class="k">await</span> <span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEachAsync</span><span class="p">(</span><span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="m">100</span><span class="p">),</span> <span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">token</span><span class="p">)</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">ValueTask</span><span class="p">.</span><span class="n">CompletedTask</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// Executes each of the provided actions, possibly in parallel.</span>
<span class="n">Parallel</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="p">},</span> <span class="k">delegate</span> <span class="p">{</span> <span class="p">});</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">string</span> <span class="n">path</span> <span class="p">=</span> <span class="n">Path</span><span class="p">.</span><span class="nf">Combine</span><span class="p">(</span>
    <span class="n">Environment</span><span class="p">.</span><span class="nf">GetFolderPath</span><span class="p">(</span><span class="n">Environment</span><span class="p">.</span><span class="n">SpecialFolder</span><span class="p">.</span><span class="n">UserProfile</span><span class="p">),</span> <span class="s">".nuget/packages/"</span><span class="p">);</span>
<span class="kt">string</span><span class="p">[]</span> <span class="n">fileNames</span> <span class="p">=</span> <span class="n">Directory</span><span class="p">.</span><span class="nf">GetFiles</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"*"</span><span class="p">,</span> <span class="n">SearchOption</span><span class="p">.</span><span class="n">AllDirectories</span><span class="p">);</span>

<span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">sw</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
    <span class="kt">long</span> <span class="n">parallelTotalSize</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="n">Parallel</span><span class="p">.</span><span class="nf">ForEach</span><span class="p">(</span><span class="n">fileNames</span><span class="p">,</span>
        <span class="n">fileName</span> <span class="p">=&gt;</span> <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">parallelTotalSize</span><span class="p">,</span> <span class="k">new</span> <span class="nf">FileInfo</span><span class="p">(</span><span class="n">fileName</span><span class="p">).</span><span class="n">Length</span><span class="p">));</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Parallel: </span><span class="p">{</span><span class="n">parallelTotalSize</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s">ms"</span><span class="p">);</span>

    <span class="n">sw</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
    <span class="kt">long</span> <span class="n">totalSize</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">fileName</span> <span class="k">in</span> <span class="n">fileNames</span><span class="p">)</span> <span class="n">totalSize</span> <span class="p">+=</span> <span class="k">new</span> <span class="nf">FileInfo</span><span class="p">(</span><span class="n">fileName</span><span class="p">).</span><span class="n">Length</span><span class="p">;</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Sequential : </span><span class="p">{</span><span class="n">totalSize</span><span class="p">}</span><span class="s">, </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s">ms"</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// Parallel: 2743226084, 400ms</span>
<span class="c1">// Sequential : 2743226084, 598ms</span>
<span class="c1">// Parallel: 2743226084, 220ms</span>
<span class="c1">// Sequential : 2743226084, 429ms</span></code></pre>
</div>
</div>
</li>
<li>
<p>When a parallel loop runs, the TPL partitions the data source so that the loop can operate on multiple parts concurrently.</p>
<div class="openblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Behind the scenes, the Task Scheduler partitions the task based on system resources and workload.</p>
</li>
<li>
<p>When possible, the scheduler redistributes work among multiple threads and processors if the workload becomes unbalanced.</p>
</li>
</ul>
</div>
</div>
</div>
</li>
<li>
<p>Data parallelism with declarative, or query-like, syntax is supported by <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq">PLINQ</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><strong>False sharing</strong> occurs when multiple threads modify variables that reside on the same CPU cache line, leading to performance degradation due to unnecessary cache invalidations.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modern CPUs use <strong>cache lines</strong> (typically 64 bytes) to store and access memory efficiently.</p>
</li>
<li>
<p>When a thread modifies a memory location, the CPU must ensure that all other cores have the latest value.</p>
</li>
<li>
<p>If two threads modify separate variables but these variables share the same cache line, they <strong>invalidate each other’s cache</strong>, forcing frequent synchronization between cores.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">using</span> <span class="nn">BenchmarkDotNet.Attributes</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">BenchmarkDotNet.Running</span><span class="p">;</span>

<span class="n">BenchmarkSwitcher</span><span class="p">.</span><span class="nf">FromAssembly</span><span class="p">(</span><span class="k">typeof</span><span class="p">(</span><span class="n">Program</span><span class="p">).</span><span class="n">Assembly</span><span class="p">).</span><span class="nf">Run</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

<span class="p">[</span><span class="n">ShortRunJob</span><span class="p">]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">Tests</span>
<span class="p">{</span>
    <span class="c1">// The _values array is contiguous in memory.</span>
    <span class="c1">// Each int is 4 bytes, so the whole array takes 128 bytes.</span>
    <span class="c1">// A cache line is typically 64 bytes, meaning 16 int values fit in one cache line.</span>
    <span class="c1">// When Index = 1: _values[0] and _values[1] share the same cache line</span>
    <span class="c1">//  → high false sharing → performance is worse.</span>
    <span class="c1">// When Index = 31: _values[0] and _values[31] are in different cache lines</span>
    <span class="c1">//  → no false sharing → performance is better.</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span><span class="p">[]</span> <span class="n">_values</span> <span class="p">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="m">32</span><span class="p">];</span>

    <span class="p">[</span><span class="nf">Params</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">31</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="p">[</span><span class="n">Benchmark</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Invoke</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Parallel</span><span class="p">.</span><span class="nf">Invoke</span><span class="p">(</span>
            <span class="p">()</span> <span class="p">=&gt;</span> <span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">_values</span><span class="p">[</span><span class="m">0</span><span class="p">]),</span>
            <span class="p">()</span> <span class="p">=&gt;</span> <span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">_values</span><span class="p">[</span><span class="n">Index</span><span class="p">])</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100_000_000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="k">value</span><span class="p">);</span>
            <span class="c1">// value++; // no synchronization overhead</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="p">[</span><span class="nf">StructLayout</span><span class="p">(</span><span class="n">LayoutKind</span><span class="p">.</span><span class="n">Sequential</span><span class="p">,</span> <span class="n">Size</span> <span class="p">=</span> <span class="m">64</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">ref</span> <span class="k">struct</span> <span class="nc">PaddedInt32</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Value</span><span class="p">;</span>
<span class="p">}</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="dataflow">3.3. Dataflow</h3>
<div class="paragraph">
<p>The Task Parallel Library (TPL) offers the <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library">TPL Dataflow Library</a>, which enhances concurrency in applications by supporting actor-based programming and in-process message passing for coarse-grained dataflow and pipelining tasks. <a href="#dataflow-task-parallel-library">[21]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>The TPL Dataflow Library provides a foundation for message passing and parallelizing CPU-intensive and I/O-intensive applications that have <em>high throughput</em> and <em>low latency</em>.</p>
</li>
<li>
<p>The TPL Dataflow Library consists of <em>dataflow blocks</em>,  <em>source blocks</em>, <em>target blocks</em>, and <em>propagator blocks</em>,  which are data structures that buffer and process data.</p>
<div class="ulist">
<ul>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.isourceblock-1">source block</a> acts as a source of data and can be read from.</p>
</li>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.itargetblock-1">target block</a> acts as a receiver of data and can be written to.</p>
</li>
<li>
<p>A <a href="https://learn.microsoft.com/en-us/dotnet/api/system.threading.tasks.dataflow.ipropagatorblock-2">propagator block</a> acts as both a source block and a target block, and can be read from and written to.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Dataflow blocks can be connected to form pipelines, which are linear sequences of dataflow blocks, or networks, which are graphs of dataflow blocks.</p>
<div class="ulist">
<ul>
<li>
<p>In a pipeline or network, sources asynchronously propagate data to targets as that data becomes available.</p>
</li>
<li>
<p>The <code>ISourceBlock&lt;TOutput&gt;.LinkTo</code> method links a source dataflow block to a target block.</p>
</li>
<li>
<p>A source can be linked to zero or more targets; targets can be linked from zero or more sources.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The dataflow programming model is related to the concept of message passing, where independent components of a program communicate with one another by sending messages.</p>
<div class="ulist">
<ul>
<li>
<p>One way to propagate messages among application components is to call the</p>
<div class="ulist">
<ul>
<li>
<p><code>Post</code> (synchronous) and <code>SendAsync</code> (asynchronous) methods to send messages to target dataflow blocks, and the</p>
</li>
<li>
<p><code>Receive</code>, <code>ReceiveAsync</code>, and <code>TryReceive</code> methods to receive messages from source blocks.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="parallel-linq-plinq">3.4. Parallel LINQ (PLINQ)</h3>
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/">Language-Integrated Query (LINQ)</a> is the name for a set of technologies based on the integration of query capabilities directly into the C# language. <a href="#dotnet-csharp-linq">[19]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>With LINQ, a query is a first-class language construct, just like classes, methods, and events.</p>
</li>
<li>
<p>A query expression, the most visible "language-integrated" part of LINQ, is written in a declarative query syntax that performs filtering, ordering, and grouping operations on data sources with a minimum of code.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span> <span class="n">SelectCompiler</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ArgumentNullException</span><span class="p">.</span><span class="nf">ThrowIfNull</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
    <span class="n">ArgumentNullException</span><span class="p">.</span><span class="nf">ThrowIfNull</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>

    <span class="k">return</span> <span class="nf">Impl</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>

    <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span> <span class="nf">Impl</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">source</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="nf">selector</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span> <span class="n">SelectManual</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ArgumentNullException</span><span class="p">.</span><span class="nf">ThrowIfNull</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
    <span class="n">ArgumentNullException</span><span class="p">.</span><span class="nf">ThrowIfNull</span><span class="p">(</span><span class="n">selector</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="n">SelectManualEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;(</span><span class="n">source</span><span class="p">,</span> <span class="n">selector</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">sealed</span> <span class="k">class</span> <span class="nc">SelectManualEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;,</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">&gt;</span> <span class="n">_source</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">_selector</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_threadId</span> <span class="p">=</span> <span class="n">Environment</span><span class="p">.</span><span class="n">CurrentManagedThreadId</span><span class="p">;</span>

    <span class="k">private</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">&gt;?</span> <span class="n">_enumerator</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">TResult</span> <span class="n">_current</span> <span class="p">=</span> <span class="k">default</span><span class="p">!;</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">_state</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">SelectManualEnumerable</span><span class="p">(</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;</span> <span class="n">selector</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_source</span> <span class="p">=</span> <span class="n">source</span><span class="p">;</span>
        <span class="n">_selector</span> <span class="p">=</span> <span class="n">selector</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_threadId</span> <span class="p">==</span> <span class="n">Environment</span><span class="p">.</span><span class="n">CurrentManagedThreadId</span> <span class="p">&amp;&amp;</span> <span class="n">_state</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_state</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="k">new</span> <span class="n">SelectManualEnumerable</span><span class="p">&lt;</span><span class="n">TSource</span><span class="p">,</span> <span class="n">TResult</span><span class="p">&gt;(</span><span class="n">_source</span><span class="p">,</span> <span class="n">_selector</span><span class="p">)</span> <span class="p">{</span> <span class="n">_state</span> <span class="p">=</span> <span class="m">1</span> <span class="p">};</span>
    <span class="p">}</span>

    <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="nf">GetEnumerator</span><span class="p">();</span>

    <span class="k">public</span> <span class="n">TResult</span> <span class="n">Current</span> <span class="p">=&gt;</span> <span class="n">_current</span><span class="p">;</span>

    <span class="kt">object</span><span class="p">?</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">=&gt;</span> <span class="n">Current</span><span class="p">;</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">_state</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
        <span class="n">_current</span> <span class="p">=</span> <span class="k">default</span><span class="p">!;</span>
        <span class="n">_enumerator</span><span class="p">?.</span><span class="nf">Dispose</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">_state</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">case</span> <span class="m">1</span><span class="p">:</span>
                <span class="n">_enumerator</span> <span class="p">=</span> <span class="n">_source</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">();</span>
                <span class="n">_state</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
                <span class="k">goto</span> <span class="k">case</span> <span class="m">2</span><span class="p">;</span>
            <span class="k">case</span> <span class="m">2</span><span class="p">:</span>
                <span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">_enumerator</span> <span class="k">is</span> <span class="k">not</span> <span class="k">null</span><span class="p">);</span>
                <span class="k">try</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">_enumerator</span><span class="p">.</span><span class="nf">MoveNext</span><span class="p">())</span>
                    <span class="p">{</span>
                        <span class="n">_current</span> <span class="p">=</span> <span class="nf">_selector</span><span class="p">(</span><span class="n">_enumerator</span><span class="p">.</span><span class="n">Current</span><span class="p">);</span>
                        <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">catch</span>
                <span class="p">{</span>
                    <span class="nf">Dispose</span><span class="p">();</span>
                    <span class="k">throw</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nf">Dispose</span><span class="p">();</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nf">Dispose</span><span class="p">();</span>
        <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">NotSupportedException</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>At compile time, <em>query expressions</em> are converted to <em>standard query operator</em> method calls according to the rules defined in the C# specification.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Any query that can be expressed by using <em>query syntax</em> can also be expressed by using <em>method syntax</em>.</p>
</li>
<li>
<p>In some cases, query syntax is more readable and concise. In others, method syntax is more readable.</p>
</li>
<li>
<p>There&#8217;s no semantic or performance difference between the two different forms.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">string</span> <span class="n">sentence</span> <span class="p">=</span> <span class="s">"the quick brown fox jumps over the lazy dog"</span><span class="p">;</span>
<span class="c1">// Split the string into individual words to create a collection.</span>
<span class="kt">string</span><span class="p">[]</span> <span class="n">words</span> <span class="p">=</span> <span class="n">sentence</span><span class="p">.</span><span class="nf">Split</span><span class="p">(</span><span class="sc">' '</span><span class="p">);</span>

<span class="c1">// Using query expression syntax.</span>
<span class="kt">var</span> <span class="n">query</span> <span class="p">=</span> <span class="k">from</span> <span class="n">word</span> <span class="k">in</span> <span class="n">words</span>
            <span class="k">group</span> <span class="n">word</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">()</span> <span class="k">by</span> <span class="n">word</span><span class="p">.</span><span class="n">Length</span> <span class="k">into</span> <span class="n">gr</span>
            <span class="k">orderby</span> <span class="n">gr</span><span class="p">.</span><span class="n">Key</span>
            <span class="k">select</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Length</span> <span class="p">=</span> <span class="n">gr</span><span class="p">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Words</span> <span class="p">=</span> <span class="n">gr</span> <span class="p">};</span>

<span class="c1">// Using method-based query syntax.</span>
<span class="kt">var</span> <span class="n">query2</span> <span class="p">=</span> <span class="n">words</span><span class="p">.</span>
    <span class="nf">GroupBy</span><span class="p">(</span><span class="n">w</span> <span class="p">=&gt;</span> <span class="n">w</span><span class="p">.</span><span class="n">Length</span><span class="p">,</span> <span class="n">w</span> <span class="p">=&gt;</span> <span class="n">w</span><span class="p">.</span><span class="nf">ToUpper</span><span class="p">()).</span>
    <span class="nf">Select</span><span class="p">(</span><span class="n">g</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="p">{</span> <span class="n">Length</span> <span class="p">=</span> <span class="n">g</span><span class="p">.</span><span class="n">Key</span><span class="p">,</span> <span class="n">Words</span> <span class="p">=</span> <span class="n">g</span> <span class="p">}).</span>
    <span class="nf">OrderBy</span><span class="p">(</span><span class="n">o</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>

<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">obj</span> <span class="k">in</span> <span class="n">query</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"Words of length {0}:"</span><span class="p">,</span> <span class="n">obj</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">string</span> <span class="n">word</span> <span class="k">in</span> <span class="n">obj</span><span class="p">.</span><span class="n">Words</span><span class="p">)</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To enable LINQ querying of a data source, there are different approaches based on whether the data is in-memory or remote:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In-memory data</p>
<div class="ulist">
<ul>
<li>
<p>If the data implements <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1"><code>IEnumerable&lt;T&gt;</code></a>, <em>LINQ to Objects</em> can be used to query it directly.</p>
</li>
<li>
<p>If <a href="https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1"><code>IEnumerable&lt;T&gt;</code></a> is not implemented, define LINQ standard query operator methods in the type or as extension methods.</p>
</li>
<li>
<p>To implement <strong>deferred execution</strong>, return an <code>IEnumerable&lt;T&gt;</code> or <code>IQueryable&lt;T&gt;</code> that yields elements instead of returning a concrete collection (<code>List&lt;T&gt;</code>, <code>Array</code>, etc.).</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">public</span> <span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">MyWhere</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">source</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">bool</span><span class="p">&gt;</span> <span class="n">predicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">source</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">predicate</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="n">item</span><span class="p">;</span> <span class="c1">// Deferred execution happens here</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>Remote data</p>
<div class="ulist">
<ul>
<li>
<p>The best option for enabling LINQ querying of a remote data source is to implement the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.iqueryable-1"><code>IQueryable&lt;T&gt;</code></a> interface.</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="k">using</span> <span class="nn">var</span> <span class="n">db</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AppDbContext</span><span class="p">();</span> <span class="c1">// Microsoft.EntityFrameworkCore.DbContext</span>

<span class="c1">// IQueryable&lt;T&gt; -&gt; Translates into SQL and executes in the database</span>
<span class="kt">var</span> <span class="n">expensiveProducts</span> <span class="p">=</span> <span class="n">db</span><span class="p">.</span><span class="n">Products</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="n">p</span><span class="p">.</span><span class="n">Price</span> <span class="p">&gt;</span> <span class="m">100</span><span class="p">);</span>

<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"SQL Query is not executed yet!"</span><span class="p">);</span>

<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">product</span> <span class="k">in</span> <span class="n">expensiveProducts</span><span class="p">)</span> <span class="c1">// Execution happens here</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"</span><span class="p">{</span><span class="n">product</span><span class="p">.</span><span class="n">Name</span><span class="p">}</span><span class="s">: $</span><span class="p">{</span><span class="n">product</span><span class="p">.</span><span class="n">Price</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq">Parallel LINQ (PLINQ)</a> is a parallel implementation of the <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/">Language-Integrated Query (LINQ)</a> pattern. <a href="#introduction-to-plinq">[20]</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p>PLINQ implements the full set of LINQ standard query operators as extension methods for the <a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq">System.Linq</a> namespace and has additional operators for parallel operations.</p>
</li>
<li>
<p>PLINQ combines the simplicity and readability of LINQ syntax with the power of parallel programming.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A PLINQ query in many ways resembles a non-parallel LINQ to Objects query.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>PLINQ queries, just like sequential LINQ queries, operate on any in-memory <code>IEnumerable</code> or <code>IEnumerable&lt;T&gt;</code> data source, and have deferred execution, which means they do not begin executing until the query is enumerated.</p>
</li>
<li>
<p>The primary difference is that PLINQ attempts to make full use of all the processors on the system by partitioning the data source into segments, and then executing the query on each segment on separate worker threads in parallel on multiple processors.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable">System.Linq.ParallelEnumerable</a> class exposes almost all of PLINQ&#8217;s functionality that includes implementations of all the standard query operators that LINQ to Objects supports, although it does not attempt to parallelize each one, and also contains a set of methods that enable behaviors specific to parallel execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">files</span> <span class="p">=</span> <span class="n">Directory</span><span class="p">.</span><span class="nf">EnumerateFiles</span><span class="p">(</span><span class="s">"/usr/share/man"</span><span class="p">,</span> <span class="s">"*.gz"</span><span class="p">,</span> <span class="n">SearchOption</span><span class="p">.</span><span class="n">AllDirectories</span><span class="p">);</span>

<span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">sw</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">parallelTopLetter</span> <span class="p">=</span> <span class="n">files</span>
        <span class="p">.</span><span class="nf">AsParallel</span><span class="p">()</span> <span class="c1">// opt in to PLINQ</span>
        <span class="c1">// .WithExecutionMode(ParallelExecutionMode.ForceParallelism)</span>
        <span class="c1">// .WithDegreeOfParallelism(Environment.ProcessorCount)</span>
        <span class="c1">// .WithCancellation(CancellationToken.None)</span>
        <span class="c1">// .WithMergeOptions(ParallelMergeOptions.Default)</span>
        <span class="c1">// .AsUnordered()</span>
        <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">SplitLetters</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">SelectMany</span><span class="p">(</span><span class="n">w</span> <span class="p">=&gt;</span> <span class="n">w</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">GroupBy</span><span class="p">(</span><span class="kt">char</span><span class="p">.</span><span class="n">ToLower</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">OrderByDescending</span><span class="p">(</span><span class="n">g</span> <span class="p">=&gt;</span> <span class="n">g</span><span class="p">.</span><span class="nf">Count</span><span class="p">())</span>
        <span class="p">.</span><span class="nf">First</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Parallel: </span><span class="p">{</span><span class="n">parallelTopLetter</span><span class="p">.</span><span class="n">Key</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">parallelTopLetter</span><span class="p">.</span><span class="nf">Count</span><span class="p">()}</span><span class="s">, </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s">ms"</span><span class="p">);</span>

    <span class="n">sw</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">sequentialTopLetter</span> <span class="p">=</span> <span class="n">files</span> <span class="c1">// .AsParallel().AsSequential()</span>
        <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">SplitLetters</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">SelectMany</span><span class="p">(</span><span class="n">w</span> <span class="p">=&gt;</span> <span class="n">w</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">GroupBy</span><span class="p">(</span><span class="kt">char</span><span class="p">.</span><span class="n">ToLower</span><span class="p">)</span>
        <span class="p">.</span><span class="nf">OrderByDescending</span><span class="p">(</span><span class="n">g</span> <span class="p">=&gt;</span> <span class="n">g</span><span class="p">.</span><span class="nf">Count</span><span class="p">())</span>
        <span class="p">.</span><span class="nf">First</span><span class="p">();</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Sequential: </span><span class="p">{</span><span class="n">sequentialTopLetter</span><span class="p">.</span><span class="n">Key</span><span class="p">}</span><span class="s">: </span><span class="p">{</span><span class="n">sequentialTopLetter</span><span class="p">.</span><span class="nf">Count</span><span class="p">()}</span><span class="s">, </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s">ms"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">char</span><span class="p">&gt;</span> <span class="nf">SplitLetters</span><span class="p">(</span><span class="kt">string</span> <span class="n">fileName</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">fileStream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FileStream</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="n">FileMode</span><span class="p">.</span><span class="n">Open</span><span class="p">,</span> <span class="n">FileAccess</span><span class="p">.</span><span class="n">Read</span><span class="p">);</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">gzipStream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">GZipStream</span><span class="p">(</span><span class="n">fileStream</span><span class="p">,</span> <span class="n">CompressionMode</span><span class="p">.</span><span class="n">Decompress</span><span class="p">);</span>
    <span class="k">using</span> <span class="nn">var</span> <span class="n">reader</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StreamReader</span><span class="p">(</span><span class="n">gzipStream</span><span class="p">);</span>
    <span class="kt">string</span><span class="p">?</span> <span class="n">line</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">line</span> <span class="p">=</span> <span class="n">reader</span><span class="p">.</span><span class="nf">ReadLine</span><span class="p">())</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="k">in</span> <span class="n">line</span><span class="p">.</span><span class="nf">ToCharArray</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="kt">char</span><span class="p">.</span><span class="nf">IsLetter</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                <span class="k">yield</span> <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// deferred execution</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// Parallel: e: 29241, 132ms</span>
<span class="c1">// Sequential: e: 29241, 50ms</span>
<span class="c1">// Parallel: e: 29241, 32ms</span>
<span class="c1">// Sequential: e: 29241, 34ms</span></code></pre>
</div>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 75%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ParallelEnumerable Operator</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.asparallel"><code>AsParallel</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The entry point for PLINQ. Specifies that the rest of the query should be parallelized, if it is possible.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.assequential"><code>AsSequential</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies that the rest of the query should be run sequentially, as a non-parallel LINQ query.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.asordered"><code>AsOrdered</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies that PLINQ should preserve the ordering of the source sequence for the rest of the query, or until the ordering is changed, for example by the use of an orderby (Order By in Visual Basic) clause.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.asunordered"><code>AsUnordered</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies that PLINQ for the rest of the query is not required to preserve the ordering of the source sequence.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.withcancellation"><code>WithCancellation</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies that PLINQ should periodically monitor the state of the provided cancellation token and cancel execution if it is requested.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.withdegreeofparallelism"><code>WithDegreeOfParallelism</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies the maximum number of processors that PLINQ should use to parallelize the query.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.withmergeoptions"><code>WithMergeOptions</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Provides a hint about how PLINQ should, if it is possible, merge parallel results back into just one sequence on the consuming thread.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.withexecutionmode"><code>WithExecutionMode</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Specifies whether PLINQ should parallelize the query even when the default behavior would be to run it sequentially.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.forall"><code>ForAll</code></a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A multithreaded enumeration method that, unlike iterating over the results of the query, enables results to be processed in parallel without first merging back to the consumer thread.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://learn.microsoft.com/en-us/dotnet/api/system.linq.parallelenumerable.aggregate"><code>Aggregate</code></a> overload</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">An overload that is unique to PLINQ and enables intermediate aggregation over thread-local partitions, plus a final aggregation function to combine the results of all partitions.</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="title">ForEach and ForAll</div>
<div class="paragraph">
<p>In sequential LINQ queries, execution is deferred until the query is enumerated either in a <code>foreach</code> loop or by invoking a method such as <code>ToList</code> , <code>ToArray</code> , or <code>ToDictionary</code>.</p>
</div>
<div class="paragraph">
<p>In PLINQ, <code>foreach</code> can also be used to execute the query and iterate through the results, however, the <code>foreach</code> itself does not run in parallel, and therefore, it requires that the output from all parallel tasks be merged back into the thread on which the loop is running.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>In PLINQ, <code>foreach</code> can be used when the final ordering of the query results must be preserved and when processing the results in a serial manner, for example, when calling <code>Console.WriteLine</code> for each element.</p>
</li>
<li>
<p>For faster query execution when order preservation is not required and when the processing of the results can itself be parallelized, use the <code>ForAll</code> method to execute a PLINQ query.</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/media/vs-isvnt-allvseach.png" alt="ForAll vs. ForEach" width="25%" height="25%">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">nums</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="m">10_000_000</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">query</span> <span class="p">=</span>
    <span class="k">from</span> <span class="n">num</span> <span class="k">in</span> <span class="n">nums</span><span class="p">.</span><span class="nf">AsParallel</span><span class="p">()</span>
    <span class="k">where</span> <span class="n">num</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">0</span>
    <span class="k">select</span> <span class="n">num</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">Compute</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">Math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
<span class="n">Stopwatch</span> <span class="n">sw</span> <span class="p">=</span> <span class="n">Stopwatch</span><span class="p">.</span><span class="nf">StartNew</span><span class="p">();</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">2</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
<span class="p">{</span>
    <span class="n">sw</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
    <span class="n">query</span><span class="p">.</span><span class="nf">ForAll</span><span class="p">(</span><span class="n">e</span> <span class="p">=&gt;</span> <span class="nf">Compute</span><span class="p">(</span><span class="n">e</span><span class="p">));</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Parallel: </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s">ms"</span><span class="p">);</span>

    <span class="n">sw</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">e</span> <span class="k">in</span> <span class="n">query</span><span class="p">)</span> <span class="nf">Compute</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
    <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Sequential: </span><span class="p">{</span><span class="n">sw</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">}</span><span class="s">ms"</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// Parallel: 88ms</span>
<span class="c1">// Sequential: 283ms</span>
<span class="c1">// Parallel: 53ms</span>
<span class="c1">// Sequential: 261ms</span></code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="faq">Appendix A: FAQ</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="what-happens-on-thread-sleep0-in-net">A.1. What happens on Thread.Sleep(0) in .NET?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What happens on Thread.Sleep(0) in .NET?</p>
</div>
<div class="paragraph">
<p>* In .NET, <code>Thread.Sleep(0)</code> has a special meaning. It relinquishes the thread’s current time slice immediately, voluntarily handing over the CPU to other threads. The operating system could decide to immediately give the time slice back to the same thread if there are no other threads that need to run.</p>
</div>
<div class="paragraph">
<p>It&#8217;s effectively a way to signal to the operating system that the thread is willing to give up its slice of processor time, if there are other threads that are ready to run on the same processor.</p>
</div>
<div class="paragraph">
<p>However, <code>Thread.Sleep(0)</code> does not lead to a context switch if there are no higher priority threads waiting.</p>
</div>
<div class="paragraph">
<p>This can be useful to prevent a thread from consuming too much CPU time in a busy-wait scenario or when you might want to give other threads the chance to run.</p>
</div>
<div class="paragraph">
<p>Remember that using <code>Thread.Sleep</code> is generally not the best practice because it blocks the thread and also it&#8217;s not precise i.e. the thread might not awake exactly after specified time due to the way CPU scheduling works. Instead, using techniques such as <code>Task</code>, <code>async/await</code>, or the TPL&#8217;s synchronization primitives (like <code>ManualResetEvent</code>, <code>Semaphore</code>, etc.) are typically better approaches for managing thread synchronization and timing.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="what-are-the-worker-and-completion-port-threads">A.2. What are the worker and completion port threads?</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="c1">//</span>
<span class="c1">// Summary:</span>
<span class="c1">//     Sets the number of requests to the thread pool that can be active concurrently.</span>
<span class="c1">//     All requests above that number remain queued until thread pool threads become</span>
<span class="c1">//     available.</span>
<span class="c1">//</span>
<span class="c1">// Parameters:</span>
<span class="c1">//   workerThreads:</span>
<span class="c1">//     The maximum number of worker threads in the thread pool.</span>
<span class="c1">//</span>
<span class="c1">//   completionPortThreads:</span>
<span class="c1">//     The maximum number of asynchronous I/O threads in the thread pool.</span>
<span class="c1">//</span>
<span class="c1">// Returns:</span>
<span class="c1">//     true if the change is successful; otherwise, false.</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SetMaxThreads</span><span class="p">(</span><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="nf">SetMinThreads</span><span class="p">(</span><span class="kt">int</span> <span class="n">workerThreads</span><span class="p">,</span> <span class="kt">int</span> <span class="n">completionPortThreads</span><span class="p">);</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What are the worker and completion port threads in SetMaxThreads(int workerThreads, int completionPortThreads)?</p>
</div>
<div class="paragraph">
<p>* The <code>ThreadPool.SetMaxThreads(int workerThreads, int completionPortThreads)</code> method in .NET sets the number of requests to the thread pool that can be active concurrently. These two parameters define:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>workerThreads</code>: This is the maximum number of worker threads in the ThreadPool. A worker thread is a thread where your work is actually getting done. It is a thread on which a task is performed. "Worker" threads are used for compute-bound operations, i.e., your average piece of synchronous work.</p>
</li>
<li>
<p><code>completionPortThreads</code>: This indicates maximum number of asynchronous I/O threads. Completion ports are used to execute callbacks after certain Async I/O operations have completed. "I/O completion" threads are used for I/O-bound operations (typically disk and network operations).</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The threadpool maintains two types of threads, worker threads for the most part handle compute operations and I/O threads handle as the name suggests handle I/O bound operations.</p>
</div>
<div class="paragraph">
<p>Asynchronous I/O operations, which are operations that complete at some later point, often use callback methods to signal completion. When the system calls these callback methods, it does so using a thread from the ThreadPool.</p>
</div>
<div class="paragraph">
<p>The <code>ThreadPool.SetMaxThreads</code> method is usually used to increase max number of concurrent threads if you have a lot of short tasks that are I/O bound.</p>
</div>
<div class="paragraph">
<p>It&#8217;s typically not necessary to change the ThreadPool size, because the ThreadPool already optimizes the number of threads it uses based on the number of CPUs and the types of tasks it&#8217;s running. In most cases, ThreadPool is efficient in managing its threads. Its algorithm aims to efficiently use all available CPU resources while not overloading the system with too many threads at the same time. It tries to maintain a balance.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-does-net-identify-io-bound-or-compute-bound-operations">A.3. How does .NET identify I/O-bound or compute-bound operations?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How does .NET identify I/O-bound or compute-bound operations?</p>
</div>
<div class="paragraph">
<p>* The .NET runtime itself doesn&#8217;t actively categorize tasks as I/O-bound or compute-bound. It&#8217;s up to developers to ensure that appropriate APIs and techniques are used for I/O-bound and compute-bound tasks.</p>
</div>
<div class="paragraph">
<p>For I/O-bound operations, which typically include file, database, and network operations, you should use asynchronous methods when they&#8217;re available to avoid blocking (or tying up) a thread from the thread pool. When an I/O-bound operation is asynchronous, this generally means the operation is offloaded to the operating system, freeing up the .NET runtime thread to perform other work. I/O bound means the data is transferred between the CPU and the peripheral devices (disk, network, etc.), during which the CPU isn&#8217;t doing much work.</p>
</div>
<div class="paragraph">
<p>On the other hand, when a task is compute-bound, meaning it involves heavy computations and keeps the processor busy, developers should generally use synchronous methods and potentially multiple threads to utilize more cores and finish the computations faster. This kind of operation is typically done in parallel to split the work across multiple threads, where each thread uses synchronous code to do its part of the work.</p>
</div>
<div class="paragraph">
<p>So, while .NET doesn&#8217;t automatically distinguish between I/O-bound and compute-bound operations, it provides facilities (like asynchronous methods for I/O-bound tasks and parallel processing techniques such as the TPL for compute-bound tasks) for developers to write efficient code for both types of operations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How to understand 'It&#8217;s up to developers&#8230;&#8203;'?</p>
</div>
<div class="paragraph">
<p>* What "It&#8217;s up to developers&#8230;&#8203;" means is that the .NET runtime, or indeed any other runtime, cannot automatically discern if the operation you&#8217;re performing is I/O-bound or compute-bound. It&#8217;s the responsibility of the developer writing the code to understand what kind of operation they&#8217;re performing and to use the correct method to handle it.</p>
</div>
<div class="paragraph">
<p>For example,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If a developer is reading data from a file, database, or making a network call, these are typically I/O-bound operations. They should use asynchronous methods (<code>async/await</code>) provided by .NET to avoid blocking the thread while the data is being fetched.</p>
</li>
<li>
<p>If a developer is intending to perform an action that requires heavy computation, like sorting a large array or processing a complex algorithm, these operations are typically compute-bound. They would then use parallel programming constructs like <code>Parallel.For</code> or <code>Parallel.ForEach</code>, or manually creating multiple threads.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The appropriate programming approach (asynchronous or multithreaded) is dictated by the nature of the operation. The developer must know their application, the tasks, and their nature, and then use the appropriate method. The .NET runtime will not do this discernment automatically.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-does-clr-manage-the-number-of-threads-worker-and-io-threads-in-the-threadpool">A.4. How does CLR manage the number of threads (worker and I/O threads) in the ThreadPool?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How does CLR manage the number of threads (worker and I/O threads) in the ThreadPool?</p>
</div>
<div class="paragraph">
<p>* The CLR, or Common Language Runtime, uses a set algorithm to manage the number of threads in its ThreadPool.</p>
</div>
<div class="paragraph">
<p>Upon application startup, the ThreadPool possesses few threads. As requests come in, threads are added to fulfill those requests. The CLR considers several factors to make an adjustment, including the workload demand, number of processors, and the number of existing threads.</p>
</div>
<div class="paragraph">
<p>For each pending task or work item, a check is performed to see if a thread is available. If not, and the current thread count is below the maximum limit, a new thread is created unless we&#8217;ve reached the maximum limit "rate". If a ThreadPool thread is idle for some time (around a minute), it gets terminated, which reduces resource usage.</p>
</div>
<div class="paragraph">
<p>If the thread count reaches the max limit and the requests are still not fulfilled, they are queued. "Worker" threads are commonly used for executing synchronous and asynchronous managed code, and "I/O threads" are specifically designated for completing I/O-bound work.</p>
</div>
<div class="paragraph">
<p>Both the maximum threads and "rate" are automatically set based on several factors like the size of virtual memory, number of processors available, etc.</p>
</div>
<div class="paragraph">
<p>The thread injection rate (how often new threads are added) aids to prevent situations where rapidly creating too many threads would cause resource saturation and decrease performance.</p>
</div>
<div class="paragraph">
<p>You can manually get and change the minimum and maximum number of threads in the ThreadPool by using <code>GetMinThreads</code>, <code>GetMaxThreads</code>, <code>SetMinThreads</code>, and <code>SetMaxThreads</code> methods.</p>
</div>
<div class="paragraph">
<p>However, it&#8217;s recommended to let the CLR manage the threading details because of its smart heuristics and tuning based on extensive research and testing. Custom changes should only be made after careful testing and analysis.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="whats-the-algorithm-of-the-thread-pool-in-net">A.5. What&#8217;s the algorithm of the thread pool in .NET?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the algorithm of the thread pool in .NET?</p>
</div>
<div class="paragraph">
<p>* According to .NET&#8217;s official documentation, the CLR employs a hill-climbing algorithm for adjusting the number of ThreadPool threads that can run simultaneously. This heuristic algorithm is designed specifically to find the most efficient and effective number of threads for any given workload.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s how the algorithm works:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>It starts with the minimum number of ThreadPool worker threads and regularly checks if there are pending tasks in the queue which are waiting for an available thread.</p>
</li>
<li>
<p>If it finds tasks waiting in the queue, and it hasn&#8217;t already created a new thread recently, it creates a new one, up to the maximum limit.</p>
</li>
<li>
<p>If there are still tasks in the queue, but it just created a new thread, it waits a bit before creating another one. By waiting, it allows the currently running tasks to finish and free up some ThreadPool threads before deciding to create new ones.</p>
</li>
<li>
<p>If threads are idle for more than a certain time (like a minute), these threads can be retired and removed from the pool.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>This algorithm works to maintain a balance between the number of threads and the amount of work that needs to be done. By ensuring threads are only created as needed, and cleaning up idle threads, it helps to optimize the system resources and performance.</p>
</div>
<div class="paragraph">
<p>It&#8217;s important to note that the .NET ThreadPool’s algorithm is intentionally not publicly documented in detail because it&#8217;s subject to change as Microsoft fine-tunes it based on new findings and requirements.</p>
</div>
<div class="paragraph">
<p>As always, it&#8217;s recommended to let the CLR manage the ThreadPool for you, unless you have a specific reason and have done careful performance analysis.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="what-if-interlocked-increment-a-64-bit-integer-on-a-32-bit-hardware">A.6. What if Interlocked.Increment a 64-bit integer on a 32-bit hardware?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> About the Interlocked class in .NET, what if we increment a 64-bit integer on a 32-bit hardware?</p>
</div>
<div class="paragraph">
<p>* The <code>Interlocked.Increment</code> method guarantees atomic increment operations, even with a 64-bit integer on 32-bit hardware. This method is thread-safe and ensures that the increment operation completes as one uninterruptible operation.</p>
</div>
<div class="paragraph">
<p>In a multithreaded or parallel computing scenario, multiple threads might be trying to increment the value of a shared 64-bit integer simultaneously. In such a case, <code>Interlocked.Increment</code> ensures that each increment operation happens in its entirety without being interrupted by another thread. This is because, without such atomic operations, a thread could be halfway through incrementing the integer when another thread reads from or writes to it, leading to buggy and hard-to-diagnose problems.</p>
</div>
<div class="paragraph">
<p>However, performing atomic operations on a 64-bit integer (long/Int64) in 32-bit hardware requires two CPU instructions, because the size of the long value is greater than the word size of the 32-bit processor. But even then, .NET runtime ensures via <code>Interlocked.Increment</code> method that the operation is atomic at thread level and no partial updates can be seen by another thread.</p>
</div>
<div class="paragraph">
<p>Still, it&#8217;s important to note that such atomic operations come with a slightly increased performance overhead as compared to non-atomic operations, due to preventing reordering and caching of the value being incremented. Thus, they must be used judiciously.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-does-net-make-the-multiple-cpu-instructions-as-an-atomic">A.7. How does .NET make the multiple CPU instructions as an atomic?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How does CLR make the two CPU instructions as an atomic?</p>
</div>
<div class="paragraph">
<p>* The .NET Common Language Runtime (CLR) and the underlying operating system provide certain guarantees to ensure atomicity of operations on 64-bit values, even on 32-bit platforms.</p>
</div>
<div class="paragraph">
<p>The <code>Interlocked</code> class methods in .NET, like <code>Interlocked.Increment</code>, wrap platform-specific instructions for atomic operations. On a 32-bit system, where a 64-bit increment operation would generally require two CPU instructions, these interlocked operations use special instructions provided by the platform to ensure atomicity.</p>
</div>
<div class="paragraph">
<p>On Windows, for example, this can be achieved using a combination of OS-provided synchronization primitives and specific processor instructions. For instance, the <code>InterlockedIncrement64</code> function in the Windows API performs a 64-bit atomic increment operation even on a 32-bit platform.</p>
</div>
<div class="paragraph">
<p>When you call an <code>Interlocked</code> method, the .NET runtime translates that into a call to the appropriate system function or CPU instruction that guarantees the operation&#8217;s atomicity. It&#8217;s important to note that this relies on support from the operating system kernel and the CPU hardware, and the .NET runtime itself does not handle these details.</p>
</div>
<div class="paragraph">
<p>These atomic operations prevent any thread interference or inconsistencies while performing read-modify-write actions by ensuring that the operation is completed as a single, uninterruptible unit.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="i-heard-there-are-some-risk-on-atomic-operations-in-go-or-sth-else">A.8. I heard there are some risk on atomic operations in Go or sth else?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> I heard there are some risk on atomic operations in Go or sth else?</p>
</div>
<div class="paragraph">
<p>* Yes, coding with atomic operations can indeed be risky, not just in Go but in any language, if they are misused or misunderstood. Here are a few reasons why this is the case:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Atomic operations do not compose: If there are multiple separate atomic operations, there is no guarantee about the order in which they will execute or whether some other operation (not part of the atomic operation) may not interleave among them.</p>
</li>
<li>
<p>As atomic operations do not lock or synchronize larger pieces of the code, using them incorrectly can leave data in an inconsistent state if a sequence of operations (transaction) must be completed without interruption.</p>
</li>
<li>
<p>Atomic operations generally require a precise understanding of hardware, compilers, and the language memory model to be used correctly. Any misunderstanding can lead to subtle, intermittent bugs that are hard to trace or replicate.</p>
</li>
<li>
<p>Atomics can suffer from issues like ABA problems where a value changes from A to B then back to A between your atomic check and usage, causing potential problems when the code assumes the value has not changed.</p>
</li>
<li>
<p>Atomic operations are tough to debug since typical stepping debuggers might disrupt the precise timing which is usually involved in the bugs related to atomic operations.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>In Go, for example, the <code>sync/atomic</code> package provides low-level atomic memory primitives, but they are not sufficient to implement high-level synchronizations. Go encourages the use of higher-level synchronization primitives such as goroutines, channels, and select statements for most cases, and the <code>sync</code> package&#8217;s Mutex and WaitGroup types for others.</p>
</div>
<div class="paragraph">
<p>So while atomic operations are a powerful tool in concurrent programming, they are best suited for a limited set of problems and should be used judiciously and cautiously, usually when performance is a dicerning factor and you&#8217;re comfortable and proficient with the complexities of concurrent system behaviour and memory models.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="whats-aba-problems">A.9. What&#8217;s ABA problems?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s ABA problems?</p>
</div>
<div class="paragraph">
<p>* The ABA problem is a particularly tricky issue that can occur in multi-threaded or concurrent programs that use lock-free data structures and make use of atomic primitives, such as Compare-and-Swap (CAS).</p>
</div>
<div class="paragraph">
<p>Here&#8217;s a brief explanation of the ABA problem:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Say a thread, Thread A, accesses shared data and notes the value there is 'A'.</p>
</li>
<li>
<p>Thread A gets preempted, allowing Thread B to run.</p>
</li>
<li>
<p>Thread B changes the value in the shared data from 'A' to 'B', then changes it back to 'A' before it&#8217;s finished.</p>
</li>
<li>
<p>Thread A resumes execution, goes to change the shared data using a CAS operation. It checks if the value is 'A', which it is, but what Thread A doesn&#8217;t know is that the value has changed since it first loaded it. As far as Thread A can tell, though, nothing has changed, and so it goes ahead with the modification.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The result here is that Thread A acted on the assumption that nothing had changed when actually something had, but it was effectively invisible to it. This can have outcomes ranging from inconsequential to catastrophic, depending on what the shared data is used for. This is the ABA problem.</p>
</div>
<div class="paragraph">
<p>This issue is typically resolved by assigning a version number or a timestamp along with every change so that the revisiting thread can check not only the value but whether it is the same instance of the value it observed before. This kind of solution is often referred to as "tagging". Double-width Compare-and-Swap (DWCAS) or similar atomic primitives are used to atomically change the value and its associated version number or tag.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-to-understand-hardware-compilers-and-the-language-memory-model">A.10. How to understand 'hardware, compilers, and the language memory model'?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How to understand 'hardware, compilers, and the language memory model'?</p>
</div>
<div class="paragraph">
<p>* Understanding 'hardware, compilers, and the language memory model' is important when working with lower-level concurrent constructs such as atomic operations or volatile fields. Let me break them down:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Hardware: Modern CPUs can have multiple cores with their own caches. When one core updates a value in its cache, other cores won&#8217;t immediately see that change until it&#8217;s written back to main memory, or if cache-coherency protocols mark it as invalid. Similarly, hardware can execute instructions out of order for optimization purposes, which can lead to unexpected results in concurrent code.</p>
</li>
<li>
<p>Compilers: Similar to hardware, the compiler can reorder instructions or optimize away redundant loads/stores for performance. This can change the program&#8217;s behavior unless specific memory barriers or volatile qualifiers are used. Also, understanding how the hardware and compiler interact is crucial. For example, an x86 CPU has a strong memory model and won&#8217;t naturally reorder certain instructions, but the C++ compiler, without any memory barriers, is free to reorder instructions as it sees fit.</p>
</li>
<li>
<p>Language Memory Model: A language&#8217;s memory model defines how threads interact through memory and what behaviors are allowed in multi-threaded code. For instance, the C++11 memory model allows several levels of memory ordering, provides atomic operations and fences, and describes how synchronizes-with and happens-before relationships are formed. Understanding this is vital to writing correct concurrent code.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>All these can significantly impact the correctness, performance, and portability of multi-threaded code. Learning about them usually involves studying computer architecture, compilations, operating systems, and of course, the programming language&#8217;s specification. For most developers, however, using higher-level synchronization primitives and libraries that abstract these details away is sufficient and recommended.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="anyway-for-a-single-operation-like-interlocked-increment-it-will-always-ensure-it-as-an-atomic">A.11. Anyway, for a single operation like Interlocked.Increment, it will always ensure it as an atomic?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> Anyway, for a single operation like <code>Interlocked.Increment</code>, it will always ensure it as an atomic?</p>
</div>
<div class="paragraph">
<p>* Yes, for the <code>Interlocked.Increment</code> method in .NET, it always ensures atomicity of the increment operation, regardless of the system architecture (32-bit or 64-bit) and the data type of the variable being incremented (32-bit like <code>int</code> or 64-bit like <code>long</code>).</p>
</div>
<div class="paragraph">
<p>This method guarantees that the increment operation, which is otherwise a read-modify-write operation consisting of multiple steps, is executed in a single, unbroken step. No context switch or thread interference can happen in the middle of the operation that could leave the data in an inconsistent state.</p>
</div>
<div class="paragraph">
<p>It can be used safely in a multithreaded and concurrent environment, ensuring that all incrementing operations on a shared variable are done in full, one at a time.</p>
</div>
<div class="paragraph">
<p>Please be aware that while <code>Interlocked.Increment</code> ensures atomic increment operations, complex multi-step operations or transactions would require additional synchronization mechanisms, like locks or mutexes.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-to-understand-the-volatile-keyword-in-net">A.12. How to understand the volatile keyword in .NET?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How to understand the volatile keyword in .NET? And how to understand "There is no guarantee of a single total ordering of volatile writes as seen from all threads of execution."?</p>
</div>
<div class="paragraph">
<p>* The <code>volatile</code> keyword in .NET is a modifier that you can use on fields. It tells the compiler and the runtime that accesses to that field should not be subject to certain kinds of compiler or hardware optimizations such as caching its value in a register or reordering reads and writes.</p>
</div>
<div class="paragraph">
<p>In multithreaded applications, the <code>volatile</code> keyword can be used to ensure that modification to a value by one thread is immediately visible to other threads. Without <code>volatile</code>, the changes one thread makes to the field could be stored in a register and not written back to the memory location until later, causing another thread to see out-of-date values.</p>
</div>
<div class="paragraph">
<p>The quote "There is no guarantee of a single total ordering of volatile writes as seen from all threads of execution" means that the order in which threads observe volatile writes may not be consistent across all threads. While <code>volatile</code> ensures that each individual thread will observe the writes in the order they were performed, it doesn&#8217;t guarantee that all threads will perceive those writes in the same order.</p>
</div>
<div class="paragraph">
<p>Here&#8217;s an example to illustrate:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>Thread 1
    Volatile write to variable A
    Volatile write to variable B

Thread 2
    Volatile read from variable B
    Volatile read from variable A</code></pre>
</div>
</div>
<div class="paragraph">
<p>The volatile keyword ensures that Thread 1 will write to variable A before variable B. If Thread 2 reads variable B, it will see this write (or a later one). However, another volatile read to variable A can still return an older value. This is because the volatile read from variable B does not provide 'release-fence' semantics; it doesn&#8217;t force a refresh of all other modifications.</p>
</div>
<div class="paragraph">
<p>This is why it&#8217;s often recommended to use higher-level synchronization constructs (like <code>lock</code>, <code>Monitor</code>, <code>Mutex</code>, <code>Semaphore</code>, etc.) or the <code>System.Threading.Interlocked</code> class for complex synchronization, because they provide stronger guarantees about how they behave in multithreaded scenarios. The <code>volatile</code> keyword is a low-level mechanism that&#8217;s harder to use correctly and it&#8217;s easy to accidentally build incorrect code when using <code>volatile</code> for complex synchronization.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How to understand "On a multiprocessor system, a volatile read operation does not guarantee to obtain the latest value written to that memory location by any processor."?</p>
</div>
<div class="paragraph">
<p>* This statement draws attention to an important fact about volatile keyword usage in .NET on a multiprocessor system where threads could be executing on different processors.</p>
</div>
<div class="paragraph">
<p>The volatile keyword in C# tells the compiler not to reorder reads or writes to a field, or cache the field in a register, which helps ensure that all reads and writes on one processor occur in the order they&#8217;re specified in the code. Because of this, the volatile keyword is helpful for ensuring consistency in a multithreaded context.</p>
</div>
<div class="paragraph">
<p>However, it does not guarantee immediate visibility on all processors. For example, if one processor writes to a volatile field and another processor reads from that field, the reading processor might not get the most recent value written by the writing processor. The reasons can include delay due to propagation of write from one processor&#8217;s cache to others (in a multiprocessor, multi-caching systems) or the order in which these reads and writes are performed.</p>
</div>
<div class="paragraph">
<p>This is why it&#8217;s stated that "On a multiprocessor system, a volatile read operation does not guarantee to obtain the latest value written to that memory location by any processor."</p>
</div>
<div class="paragraph">
<p>In general, for complex synchronization or if strong cross-processor memory guarantees are required, usage of higher-level synchronization primitives or constructs (like locks, <code>Monitor</code>, <code>Mutex</code>, <code>Semaphore</code>, <code>ConcurrentDictionary</code>, <code>Interlocked</code>, <code>MemoryBarrier</code>, etc.) should be preferred. These toolsets are built to handle advanced multithreading and synchronization tasks, giving strict guarantees about order of operations and memory visibility on multi-core and multiprocessor systems.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="whats-the-diff-of-volatile-keyword-and-volatile-class">A.13. What&#8217;s the diff of volatile keyword and Volatile class?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the diff of volatile keyword and Volatile class?</p>
</div>
<div class="paragraph">
<p>* The <code>volatile</code> keyword and <code>Volatile</code> class in .NET both provide support for using volatile memory, but they do so in slightly different ways.</p>
</div>
<div class="paragraph">
<p>The <code>volatile</code> keyword is a modifier that can be applied to fields of a class or a struct. The .NET run-time knows not to cache the value of that field and always accesses it directly from memory, which makes it useful in multithreading scenarios where you need to ensure that a specific field&#8217;s latest value is accessible across multiple threads. It provides acquire-fence semantics for reads (a read of a volatile field is guaranteed to happen after any previous memory accesses), and release-fence semantics for writes (a write to a volatile field is guaranteed to happen before any subsequent memory accesses).</p>
</div>
<div class="paragraph">
<p>The <code>Volatile</code> class, introduced in .NET Framework 4.5, provides a set of methods that perform volatile reads and writes. This is beneficial as it allows volatile operations on types that were not declared as <code>volatile</code>. It provides stronger memory guarantees: a read done via <code>Volatile.Read</code> has acquire-fence semantics, i.e., it ensures that all subsequent reads and writes occur strictly after the volatile read, and a write done via <code>Volatile.Write</code> has release-fence semantics, i.e., it ensures that all previous reads and writes happen strictly before the volatile write. It acts as a full-fence, not allowing reordering or caching optimizations around it.</p>
</div>
<div class="paragraph">
<p>So, while both are used for volatile memory operations, the <code>Volatile</code> class provides stronger guarantees and offers more flexibility because it lets you perform volatile operations on non-volatile declared variables, while the <code>volatile</code> keyword is simpler to use but only operates on fields declared as <code>volatile</code>.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="it-seems-we-should-avoid-to-use-the-volatile-keyword">A.14. It seems we should avoid to use the volatile keyword?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> It&#8217;s about the happen-before on a memory model. It seems we should avoid to use the volatile keyword?</p>
</div>
<div class="paragraph">
<p>* In general, understanding and correctly using the <code>volatile</code> keyword can be tricky. <code>volatile</code> only provides a very specific type of memory barrier, and can be misused easily. Beginners often have misunderstandings about what <code>volatile</code> actually does.</p>
</div>
<div class="paragraph">
<p>The primary purpose of <code>volatile</code> is to provide a way to declare fields that can be modified by multiple threads, to indicate that such fields should not be subject to certain compiler and hardware optimizations. Essentially, no caching, no reordering, etc.</p>
</div>
<div class="paragraph">
<p>However, using <code>volatile</code> won&#8217;t prevent all problems with visibility or ordering of operations. It does not provide atomicity, and often it&#8217;s not strong enough to replace other types of synchronization. For example, complex state manipulation or operations involving more than one memory location, like switching pointers or managing linked nodes, often need to be done in a single, uninterruptible step. Those operations are far beyond the scope of <code>volatile</code>.</p>
</div>
<div class="paragraph">
<p>Higher-level concurrency constructs (<code>lock</code>, <code>Monitor</code>, <code>Mutex</code>, <code>Semaphore</code>, <code>ManualResetEvent</code>, <code>AutoResetEvent</code>, and types in <code>System.Collections.Concurrent</code> or <code>System.Threading.Tasks</code>) should be preferred. These handle most of the complexity of ensuring correct memory barriers and state visibility, and they are generally safer and more efficient choices.</p>
</div>
<div class="paragraph">
<p><code>Interlocked</code> class also offers atomic operations for a single memory location and can be used for lightweight synchronization in high-performance scenarios, although understanding and using it correctly can be as tricky as <code>volatile</code>.</p>
</div>
<div class="paragraph">
<p>In the end, <code>volatile</code> isn’t something you should be reaching for regularly. Its usage should be limited to very specific cases. In general, you are better off using a higher-level synchronization construct in .NET when dealing with multithreading scenarios.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="whats-the-diff-of-asynchronous-and-parallel-programming-in-net">A.15. What&#8217;s the diff of asynchronous and parallel programming in .NET?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the diff of asynchronous and parallel programming in .NET?</p>
</div>
<div class="paragraph">
<p>* In .NET, both asynchronous and parallel programming paradigms are used to execute code that can potentially run concurrently to improve performance. However, they are used in different scenarios and address different types of problems.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Asynchronous Programming:</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Asynchronous programming is about freeing up the main executing thread to do other work when it would otherwise be blocked, usually waiting for I/O operations (like reading a file, downloading from the internet, querying a database, etc.).</p>
</div>
<div class="paragraph">
<p>The goal of asynchronous programming is to make the application more responsive. With async programming, the application can yield control while it waits on these long-running tasks, allowing it to perform other tasks concurrently.</p>
</div>
<div class="paragraph">
<p>In .NET, you often see <code>async</code> and <code>await</code> keywords for asynchronous programming. It does not necessarily create more threads, but uses the .NET framework&#8217;s ability to efficiently handle I/O bound tasks.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Parallel Programming:</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Parallel programming, on the other hand, is about executing multiple operations, or tasks, at the same time by utilizing multiple cores of the CPU.</p>
</div>
<div class="paragraph">
<p>This is particularly helpful for CPU-bound work that can be broken down into smaller, independent tasks and processed in parallel. For example, if you&#8217;re processing an array of elements, you can use parallel programming to process multiple elements at the same time in different cores.</p>
</div>
<div class="paragraph">
<p>In .NET, this could be achieved using the <code>Parallel</code> class (like <code>Parallel.For</code>, <code>Parallel.ForEach</code>), or <code>PLINQ (Parallel LINQ)</code>, or creating <code>Tasks</code> manually, and these generally involve multi-threading.</p>
</div>
<div class="paragraph">
<p>In summary, use asynchronous programming when dealing with I/O-bound tasks to avoid blocking and keep the application responsive, and use parallel programming when trying to break down CPU-intensive tasks to run simultaneously to improve throughput.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="whats-the-control-meaning-in-async-and-await-programming">A.16. What&#8217;s the control meaning in async and await programming?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the 'control' meaning in async and await programming?</p>
</div>
<div class="paragraph">
<p>* In the context of asynchronous programming with <code>async</code> and <code>await</code>, "control" refers to the flow of execution in a program.</p>
</div>
<div class="paragraph">
<p>When you call an <code>async</code> method, control is returned to the caller as soon as an <code>await</code> statement is encountered and the awaited operation is not yet complete. The remainder of the async method then continues to execute "in the background" and the calling code can proceed to do other work without waiting for the <code>async</code> method to complete.</p>
</div>
<div class="paragraph">
<p>When the awaited operation (such as an I/O operation, web request, etc.) completes, the remainder of the <code>async</code> method is then executed. This may involve a "context switch" back to the original context where the <code>await</code> was called (for example, the user interface thread), but the important point is that the initial call to the <code>async</code> method doesn&#8217;t block and hold up that original context while the awaited operation is ongoing.</p>
</div>
<div class="paragraph">
<p>So "yielding control" in <code>async</code>/<code>await</code> programming means giving back the control of execution to the caller code immediately, without waiting for the async method to finish, thus keeping the application responsive for doing other tasks. It&#8217;s an effective way to achieve concurrency, particularly for I/O-bound operations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the underneath in 'control', like a thread or sth else?</p>
</div>
<div class="paragraph">
<p>* "Control" primarily refers to the sequence of execution of code or the flow of a program. When we talk about control in the context of <code>async</code> and <code>await</code>, we are referring to which code or operation gets to use the executing thread at a given time.</p>
</div>
<div class="paragraph">
<p>On a lower level in .NET runtime, this "control" is facilitated by the Task Scheduler and in many scenarios, the synchronization context. Here&#8217;s a simplified view:</p>
</div>
<div class="paragraph">
<p>When a method awaits an operation (e.g. <code>await someTask();</code>), the rest of the method is posted back to the synchronization context as a continuation. If there is no SynchronizationContext (<code>SynchronizationContext.Current</code> is null), then by default the TaskScheduler is used. This continuation implicitly captures the synchronization context that was active at the time of the await.</p>
</div>
<div class="paragraph">
<p>In a UI-based application, the synchronization context is typically tied to the main UI thread, which allows the continuation (the code following the await keyword) to be executed on the same UI thread. This makes async programming easier and safer in a UI context.</p>
</div>
<div class="paragraph">
<p>In an environment without a SynchronizationContext (like in Console applications or thread pool threads), the default TaskScheduler schedules the continuation to run on the ThreadPool.</p>
</div>
<div class="paragraph">
<p>With this in mind, when you call <code>await</code> in a method, it signs up the rest of the method to be continued later, and then returns. This frees up the current thread to go off and do other work. When the awaited task finishes, the continuation (the remainder of the method) is then executed on the captured context.</p>
</div>
<div class="paragraph">
<p>Again, this is a simplified view. In reality, there are several optimizations and mechanisms in place to make async programming more efficient and easier to use.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> Does it mean the 'someTask' will be executed on another thread?</p>
</div>
<div class="paragraph">
<p>* Not necessarily. When you call an async method, it does its work on the same thread that called it until it awaits an incomplete task. At the await, if the task isn&#8217;t already complete, the async method is paused and control returns to the caller of the async method. This all happens on the same thread, and no extra threads are created.</p>
</div>
<div class="paragraph">
<p>What happens next depends on what the awaited task is doing. Here&#8217;s a simple way to think about it:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If it&#8217;s a CPU-bound task doing computation, it may be done on another thread, especially if you specifically started the task on a thread pool thread (for example, using <code>Task.Run</code>).</p>
</li>
<li>
<p>If it&#8217;s an I/O-bound task (like reading from disk or a network operation), then actually no thread is needed while it&#8217;s waiting for the I/O operation to complete. Threads are a precious resource and I/O-bound tasks are not doing any CPU-bound computation, they&#8217;re just waiting, so it would be wasteful to dedicate a thread to that.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the awaited operation completes, the remainder of the async method is scheduled to continue running. The scheduling depends on the context when the 'await' keyword is encountered.</p>
</div>
<div class="paragraph">
<p>In a UI application, it resumes on the UI thread (as this is the captured context); for a server application, it generally runs on a ThreadPool thread, but not necessarily the same thread as the one it started.</p>
</div>
<div class="paragraph">
<p>Remember, in most cases, async doesn&#8217;t mean concurrent or multi-threaded. Async methods don&#8217;t require multithreading because an async method doesn&#8217;t run on its own thread. The method runs on the current synchronization context and uses time on the thread only when the method is active.</p>
</div>
<div class="paragraph">
<p>You can use <code>Task.Run</code> to queue work on the ThreadPool if you want to use separate threads for CPU-bound work.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="how-to-understand-async-methods-dont-require-multithreading-because-an-async-method-doesnt-run-on-its-own-thread">A.17. How to understand "Async methods don&#8217;t require multithreading because an async method doesn&#8217;t run on its own thread."?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> How to understand "Async methods don&#8217;t require multithreading because an async method doesn&#8217;t run on its own thread."?</p>
</div>
<div class="paragraph">
<p>* In asynchronous programming, the fundamental misunderstanding is often thinking that "asynchronous" automatically means "on a different thread". This is not strictly true.</p>
</div>
<div class="paragraph">
<p>When you mark a method with <code>async</code>, all this does is allow the use of the <code>await</code> keyword in the method, it doesn&#8217;t inherently create a new thread for the method to run on.</p>
</div>
<div class="paragraph">
<p>An <code>async</code> method starts running on the same thread, because invoking an <code>async</code> method is just like invoking any regular method. So when an <code>async</code> method is called, it runs on the current thread in a synchronous manner until it encounters an <code>await</code> that applies to a task which has not yet completed.</p>
</div>
<div class="paragraph">
<p>At that point, assuming the task being awaited has not yet completed, the method yields and the remainder of the method is turned into a continuation that will be invoked once the awaited operation completes. What&#8217;s important to understand here is that the continuation does not have to run on the same thread where it left off - it could run on whatever thread the completed task calls back on.</p>
</div>
<div class="paragraph">
<p>So an <code>async</code> method doesn&#8217;t require multithreading because it typically offloads I/O-bound work or CPU-bound work rather than running its own ongoing work on a dedicated thread.</p>
</div>
<div class="paragraph">
<p>However, if you were to use <code>Task.Run</code> within an <code>async</code> method, that would indeed use a separate thread from the thread pool to perform the function passed to <code>Task.Run</code>, thereby enabling multithreading.</p>
</div>
<div class="paragraph">
<p>So to sum it up, <code>async</code> does not create additional threads. It simply provides a mechanism to better utilize the threads by allowing them to perform other work instead of sitting idle when waiting for operations to complete.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="can-the-asyncawait-improve-the-responsiveness-on-asp-net-core">A.18. Can the async/await improve the responsiveness on ASP.NET Core?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> Can the async/await improve the responsiveness on ASP.NET Core?</p>
</div>
<div class="paragraph">
<p>* Yes, utilizing <code>async</code> and <code>await</code> in ASP.Net Core can drastically improve application responsiveness, especially when dealing with I/O-bound operations like database calls, file reads, or API requests.</p>
</div>
<div class="paragraph">
<p>The primary benefit of using <code>async</code> and <code>await</code> in ASP.Net Core is not faster execution of individual requests, but rather the ability to handle more concurrent requests with the same resources. This happens because <code>async</code> and <code>await</code> enable your application to free up threads when they would otherwise be blocked, waiting for I/O-bound tasks to complete.</p>
</div>
<div class="paragraph">
<p>In a synchronous ASP.NET Core application without <code>async</code>/<code>await</code>, each incoming request is handled by a dedicated thread from the ThreadPool. If the request requires I/O-bound operation like a database query or an external API call, that thread sits idle and waits for the operation to complete, which is a waste of resources.</p>
</div>
<div class="paragraph">
<p>In ASP.NET Core, when you use async methods and await async tasks, the thread handling the request can be used for starting another request as soon as it enters a waiting state (awaiting I/O-bound operation).</p>
</div>
<div class="paragraph">
<p>So by leveraging <code>async</code> and <code>await</code> in your ASP.NET Core applications, the overall resource usage becomes more efficient and your application can handle more concurrent clients/requests. This can lead to greater scalability of your application and also, in many cases, to a better user experience through increased responsiveness.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> It seems that it is because the I/O operations are offloaded from the current thread, and release the CPU capacity. But who should
be in charge of the I/O operations?</p>
</div>
<div class="paragraph">
<p>* Yes, that&#8217;s correct. The benefit of <code>async</code>/<code>await</code> for I/O operations is to free up the current thread, rather than waiting for the I/O operation to complete. The CPU is then free to do other work.</p>
</div>
<div class="paragraph">
<p>The operating system is in charge of coordinating and managing I/O operations. When you start an I/O-bound operation, like reading from disk or making a network request, the request is sent to the operating system. The operating system takes care of the actual I/O operation, interfacing with the necessary hardware, like the disk or network card.</p>
</div>
<div class="paragraph">
<p>From your application&#8217;s perspective, once you start an I/O operation and <code>await</code> the returned task, your application doesn&#8217;t need to worry about the operation anymore. It gets a notification (in the form of the awaited task completing) when the operation is done.</p>
</div>
<div class="paragraph">
<p>So you can think of I/O-bound <code>async</code> operations as being "offloaded" to the operating system. Your application doesn&#8217;t need to use a thread to wait for the I/O operation to complete, making it available for other work. This is the key benefit of asynchrony for I/O-bound operations.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> Actually, if we use sync methods, the current thread will be in wait status for the I/O. but it  still can free up CPU.</p>
</div>
<div class="paragraph">
<p>* Yes, you&#8217;re correct. Even with synchronous I/O operations, the CPU isn&#8217;t actively engaged the whole time. The operating system still manages the I/O operation, and the CPU is freed up to perform other tasks. However, the key difference lies in the usage of threads.</p>
</div>
<div class="paragraph">
<p>In synchronous operations, the thread performing the operation goes into a wait state and cannot be used for anything else. This means the application can handle fewer concurrent operations, as it might run out of available threads if multiple I/O operations are waiting to complete.</p>
</div>
<div class="paragraph">
<p>With asynchronous operations using <code>async</code>/<code>await</code>, after initiating the I/O operation, the thread is freed up entirely - it doesn&#8217;t enter a wait state. Instead, it can be returned to the thread pool and used to service other incoming requests. This is what makes <code>async</code>/<code>await</code> so beneficial in a scenario handling many concurrent I/O-bound operations, such as a server application.</p>
</div>
<div class="paragraph">
<p>So while both sync and async free up CPU during I/O operations, async also allows for the thread to be reused during this time, leading to more efficient utilization of system resources.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> This is the non-blocking I/O in essence?</p>
</div>
<div class="paragraph">
<p>* Exactly, using <code>async</code>/<code>await</code> for I/O-bound operations is a form of non-blocking I/O.</p>
</div>
<div class="paragraph">
<p>In blocking or synchronous I/O, the execution thread is halted—or "blocked"—until the I/O operation completes. This means the thread can&#8217;t be used for any other tasks, regardless of how long the I/O operation takes.</p>
</div>
<div class="paragraph">
<p>Non-blocking or asynchronous I/O, on the other hand, starts the I/O operation and then allows the execution thread to continue other tasks. It doesn&#8217;t wait for the I/O operation to complete. Instead, it will be notified once the I/O operation is done, at which point it can proceed with any steps that depend on the result.</p>
</div>
<div class="paragraph">
<p>Thus, by enabling non-blocking I/O, the <code>async</code>/<code>await</code> pattern can improve the scalability and responsiveness of applications, particularly in scenarios handling many concurrent I/O-bound operations, such as server applications or services.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>* Here&#8217;s a summary of the key points regarding the use of <code>async</code>/<code>await</code> from the ASP.NET Core section:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Improves Responsiveness</strong>: Utilizing <code>async</code> and <code>await</code> in ASP.Net Core can drastically improve application responsiveness, particularly when dealing with I/O-bound operations like database calls, file reads, or API requests.</p>
</li>
<li>
<p><strong>Enhances Scalability</strong>: The primary benefit of using <code>async</code>/<code>await</code> in ASP.NET Core is to handle more concurrent requests with the same resources. This is achieved by freeing up threads, which would otherwise be blocked during I/O-bound tasks.</p>
</li>
<li>
<p><strong>Operating System&#8217;s Role</strong>: In <code>async</code>/<code>await</code> programming, the operating system handles the actual I/O operation. The application receives a notification when the operation is complete, reducing the need for threads to wait.</p>
</li>
<li>
<p><strong>Benefit of Async Over Sync</strong>: While both synchronous and asynchronous operations free up the CPU, asynchronous programming also frees up threads. This allows them to be reused for other tasks, leading to more efficient utilization of system resources.</p>
</li>
<li>
<p><strong>Non-Blocking I/O</strong>: Using <code>async</code>/<code>await</code> for I/O-bound operations is a form of non-blocking I/O. The I/O operation is initiated, and the thread is then freed up to continue with other tasks. This is the crux of how <code>async</code>/<code>await</code> improves the scalability and responsiveness of applications.</p>
</li>
</ol>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="is-there-a-synchronizationcontext-on-asp-net-core">A.19. Is there a SynchronizationContext on ASP.NET Core?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> Is there a SynchronizationContext on ASP.NET Core?</p>
</div>
<div class="paragraph">
<p>* No, there&#8217;s no <code>SynchronizationContext</code> in ASP.NET Core.</p>
</div>
<div class="paragraph">
<p>In traditional .NET Framework, <code>SynchronizationContext</code> is utilized to marshal operations back to the original context or thread, for instance, a particular thread in a desktop application that interacts with the user interface. This behavior is often necessary because UI updates must be performed on the main/UI thread.</p>
</div>
<div class="paragraph">
<p>In ASP.NET Framework, <code>SynchronizationContext</code> is also used to provide a "request context" - meaning that after an <code>await</code>, you&#8217;re back on the same request context.</p>
</div>
<div class="paragraph">
<p>However, ASP.NET Core does not have a <code>SynchronizationContext</code>. It&#8217;s designed to be efficient and scalable right from the start. In most Server applications, synchronization back to the original context is not necessary. Allowing the system to execute continuations on any available thread tends to be more efficient and doesn&#8217;t block resources, which helps ASP.NET Core handle many requests simultaneously.</p>
</div>
<div class="paragraph">
<p>With that said, developers need to be aware that the code after an <code>await</code> may be running on a different thread than the code before it. All access to the <code>HttpContext</code> needs to be before the <code>await</code> or within the <code>await</code> call to make sure the right context is accessed.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="whats-the-diff-of-asordered-and-asunordered-in-plinq">A.20. What&#8217;s the diff of AsOrdered and AsUnordered in PLINQ?</h3>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>> What&#8217;s the diff of AsOrdered and AsUnordered in PLINQ?</p>
</div>
<div class="paragraph">
<p>* In PLINQ, the methods <code>AsOrdered</code> and <code>AsUnordered</code> are used to determine whether the original order of the source sequence should be preserved in the output.</p>
</div>
<div class="paragraph">
<p>The <code>AsOrdered</code> method enforces that the output sequence will be in the same order as the input sequence. This means even though the operations may occur in parallel or out of order, the actual results are buffered and then delivered in the original order. This can impact performance due to the overhead of maintaining order.</p>
</div>
<div class="paragraph">
<p>The <code>AsUnordered</code> method allows the output sequence to provide data as soon as it is calculated, regardless of the input sequence&#8217;s original order. This means if the third item is processed before the second item, it can be returned before the second item.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cs"><span class="kt">var</span> <span class="n">numbers</span> <span class="p">=</span> <span class="n">Enumerable</span><span class="p">.</span><span class="nf">Range</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">10</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">squareNumbersOrdered</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span><span class="nf">AsParallel</span><span class="p">().</span><span class="nf">AsOrdered</span><span class="p">()</span>
                             <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">n</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">Thread</span><span class="p">.</span><span class="nf">SpinWait</span><span class="p">(</span><span class="m">50_000</span> <span class="p">/</span> <span class="n">n</span><span class="p">);</span> <span class="k">return</span> <span class="n">n</span> <span class="p">*</span> <span class="n">n</span><span class="p">;</span> <span class="p">});</span>

<span class="kt">var</span> <span class="n">squareNumbersUnordered</span> <span class="p">=</span> <span class="n">numbers</span><span class="p">.</span><span class="nf">AsParallel</span><span class="p">().</span><span class="nf">AsUnordered</span><span class="p">()</span>
                             <span class="p">.</span><span class="nf">Select</span><span class="p">(</span><span class="n">n</span> <span class="p">=&gt;</span> <span class="p">{</span> <span class="n">Thread</span><span class="p">.</span><span class="nf">SpinWait</span><span class="p">(</span><span class="m">50_000</span> <span class="p">/</span> <span class="n">n</span><span class="p">);</span> <span class="k">return</span> <span class="n">n</span> <span class="p">*</span> <span class="n">n</span><span class="p">;</span> <span class="p">});</span>

<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">squareNumbersOrdered</span><span class="p">));</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="kt">string</span><span class="p">.</span><span class="nf">Join</span><span class="p">(</span><span class="s">", "</span><span class="p">,</span> <span class="n">squareNumbersUnordered</span><span class="p">));</span>
<span class="c1">// $ dotnet run</span>
<span class="c1">// 1, 4, 9, 16, 25, 36, 49, 64, 81, 100</span>
<span class="c1">// 16, 49, 81, 25, 64, 100, 36, 1, 4, 9</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s important to note that by default, PLINQ tries to preserve the original order, so <code>AsUnordered</code> can be used when the order does not matter and you want to increase performance. If ordering is important, using <code>AsOrdered</code> makes this explicit, but could decrease performance due to the ordering requirement.</p>
</div>
<div class="paragraph">
<p>Partitioning is the process in which PLINQ divides the source data into multiple chunks, or partitions, so that it can process them independently and concurrently on multiple cores.</p>
</div>
<div class="paragraph">
<p>Order preservation affects this partitioning process:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>Ordered PLINQ queries (<code>AsOrdered</code>):</strong> PLINQ partitions the input such that order is preserved. Each partition except for the first has to wait for its preceding partitions to finish before it produces its output. This introduces a synchronization delay but the ordering of data is maintained.</p>
</li>
<li>
<p><strong>Unordered PLINQ queries (<code>AsUnordered</code>):</strong> PLINQ divides the input into multiple partitions, and each partition can produce and output its results independently of other partitions. This increases concurrency and performance, but data ordering is not preserved.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Generally, if the order in which results are produced doesn&#8217;t matter, you should use <code>AsUnordered</code> as it gives PLINQ more flexibility in how it performs partitioning and can often lead to better performance.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="references">References</h2>
<div class="sectionbody">
<div class="ulist bibliography">
<ul class="bibliography">
<li>
<p><a id="bib-threads-and-threading"></a>[1] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/threads-and-threading" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/threads-and-threading</a></p>
</li>
<li>
<p><a id="bib-using-threads-and-threading"></a>[2] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading</a></p>
</li>
<li>
<p><a id="bib-cancellation-in-managed-threads"></a>[3] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads</a></p>
</li>
<li>
<p><a id="pausing-and-resuming-threads"></a>[4] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/pausing-and-resuming-threads</a></p>
</li>
<li>
<p><a id="bib-the-managed-thread-pool"></a>[5] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/the-managed-thread-pool</a></p>
</li>
<li>
<p><a id="bib-overview-of-synchronization-primitives"></a>[6] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/overview-of-synchronization-primitives</a></p>
</li>
<li>
<p><a id="eventwaithandle"></a>[7] <a href="https://learn.microsoft.com/en-us/dotnet/standard/threading/eventwaithandle" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/threading/eventwaithandle</a></p>
</li>
<li>
<p><a id="an-introduction-to-system-threading-channels"></a>[8] <a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/" class="bare">https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/</a></p>
</li>
<li>
<p><a id="language-keywords-volatile"></a>[9] <a href="https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile" class="bare">https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/volatile</a></p>
</li>
<li>
<p><a id="bib-asynchronous-programming-patterns"></a>[10] <a href="https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/</a></p>
</li>
<li>
<p><a id="wpf-advanced-threading-model"></a>[11] <a href="https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/threading-model" class="bare">https://learn.microsoft.com/en-us/dotnet/desktop/wpf/advanced/threading-model</a></p>
</li>
<li>
<p><a id="bib-lazy-initialization"></a>[12] <a href="https://learn.microsoft.com/en-us/dotnet/framework/performance/lazy-initialization" class="bare">https://learn.microsoft.com/en-us/dotnet/framework/performance/lazy-initialization</a></p>
</li>
<li>
<p><a id="bib-parallel-programming"></a>[13] <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/</a></p>
</li>
<li>
<p><a id="bib-data-parallelism-task-parallel-library"></a>[14] <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/data-parallelism-task-parallel-library</a></p>
</li>
<li>
<p><a id="task-based-asynchronous-programming-1"></a>[15] <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/task-based-asynchronous-programming</a></p>
</li>
<li>
<p><a id="task-asynchronous-programming-model"></a>[16] <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model" class="bare">https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/task-asynchronous-programming-model</a></p>
</li>
<li>
<p><a id="how-async-await-really-works"></a>[17] <a href="https://devblogs.microsoft.com/dotnet/how-async-await-really-works/" class="bare">https://devblogs.microsoft.com/dotnet/how-async-await-really-works/</a></p>
</li>
<li>
<p><a id="configureawait-faq"></a>[18] <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" class="bare">https://devblogs.microsoft.com/dotnet/configureawait-faq/</a></p>
</li>
<li>
<p><a id="dotnet-csharp-linq"></a>[19] <a href="https://learn.microsoft.com/en-us/dotnet/csharp/linq/" class="bare">https://learn.microsoft.com/en-us/dotnet/csharp/linq/</a></p>
</li>
<li>
<p><a id="introduction-to-plinq"></a>[20] <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/introduction-to-plinq</a></p>
</li>
<li>
<p><a id="dataflow-task-parallel-library"></a>[21] <a href="https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library" class="bare">https://learn.microsoft.com/en-us/dotnet/standard/parallel-programming/dataflow-task-parallel-library</a></p>
</li>
<li>
<p><a id="stephencleary-aspnetcore-synchronization-context"></a>[22] <a href="https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html" class="bare">https://blog.stephencleary.com/2017/03/aspnetcore-synchronization-context.html</a></p>
</li>
<li>
<p><a id="i-o-completion-ports"></a>[23] <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports" class="bare">https://learn.microsoft.com/en-us/windows/win32/fileio/i-o-completion-ports</a></p>
</li>
<li>
<p><a id="performance-improvements-in-net-6"></a>[24] <a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/" class="bare">https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/</a></p>
</li>
<li>
<p><a id="concurrency-throttling-concurrency-in-the-clr-4-0-threadpool"></a>[25] <a href="https://learn.microsoft.com/en-us/archive/msdn-magazine/2010/september/concurrency-throttling-concurrency-in-the-clr-4-0-threadpool" class="bare">https://learn.microsoft.com/en-us/archive/msdn-magazine/2010/september/concurrency-throttling-concurrency-in-the-clr-4-0-threadpool</a></p>
</li>
<li>
<p><a id="an-introduction-to-system-threading-channels"></a>[26] <a href="https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/" class="bare">https://devblogs.microsoft.com/dotnet/an-introduction-to-system-threading-channels/</a></p>
</li>
<li>
<p><a id="executioncontext-vs-synchronizationcontext"></a>[27] <a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" class="bare">https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/</a></p>
</li>
<li>
<p><a id="understanding-the-whys-whats-and-whens-of-valuetask"></a>[28] <a href="https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/" class="bare">https://devblogs.microsoft.com/dotnet/understanding-the-whys-whats-and-whens-of-valuetask/</a></p>
</li>
<li>
<p><a id="task-run-vs-task-factory-startnew"></a>[29] <a href="https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/" class="bare">https://devblogs.microsoft.com/pfxteam/task-run-vs-task-factory-startnew/</a></p>
</li>
<li>
<p><a id="async-scenarios"></a>[30] <a href="https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios" class="bare">https://learn.microsoft.com/en-us/dotnet/csharp/asynchronous-programming/async-scenarios</a></p>
</li>
</ul>
</div>
</div>
</div>
    
<style>
  .utterances {
      max-width: 100%;
  }
</style>
<script src="https://utteranc.es/client.js"
        repo="ousiax/utterances"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>


  </div>

  <ul class="post-navigation">
    <li>
      
      <a href="/2023/12/20/what-is-http-2/">&laquo; What is HTTP/2</a>
      
    </li>
    <li>
      
      <a href="/2023/12/25/delegates-events-lambdas-in-net/">Delegates and Lambdas, Events in .NET &raquo;</a>
      
    </li>
  </ul>
</article>

      </div>
    </div>

    <footer class="site-footer">
  <div class="license">
    <span>Article licensed under <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></span>
  </div>
  
  <details open>
    <summary>Extral Links</summary>
    <div>
      
      <a href="https://jekyllrb.com/">Jekyll</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://shopify.github.io/">Liquid</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://docs.asciidoctor.org/">Asciidoctor</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="https://github.com/qqbuby/">GitHub</a>
      
      &nbsp;.&nbsp;
      
      
      <a href="/feed.xml">RSS</a>
      
      
    </div>
  </details>
  
</footer>


<!-- https://github.com/bryanbraun/anchorjs -->
<script src="/js/anchor.min.js"></script>
<script>
  anchors.add();
  anchors.remove(".site-title");
</script>




  </body>

</html>
